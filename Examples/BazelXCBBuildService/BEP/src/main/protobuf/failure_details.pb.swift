// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/failure_details.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct FailureDetails_FailureDetailMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FailureDetails_FailureDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var category: OneOf_Category? {
    get {return _storage._category}
    set {_uniqueStorage()._category = newValue}
  }

  public var interrupted: FailureDetails_Interrupted {
    get {
      if case .interrupted(let v)? = _storage._category {return v}
      return FailureDetails_Interrupted()
    }
    set {_uniqueStorage()._category = .interrupted(newValue)}
  }

  public var externalRepository: FailureDetails_ExternalRepository {
    get {
      if case .externalRepository(let v)? = _storage._category {return v}
      return FailureDetails_ExternalRepository()
    }
    set {_uniqueStorage()._category = .externalRepository(newValue)}
  }

  public var buildProgress: FailureDetails_BuildProgress {
    get {
      if case .buildProgress(let v)? = _storage._category {return v}
      return FailureDetails_BuildProgress()
    }
    set {_uniqueStorage()._category = .buildProgress(newValue)}
  }

  public var remoteOptions: FailureDetails_RemoteOptions {
    get {
      if case .remoteOptions(let v)? = _storage._category {return v}
      return FailureDetails_RemoteOptions()
    }
    set {_uniqueStorage()._category = .remoteOptions(newValue)}
  }

  public var clientEnvironment: FailureDetails_ClientEnvironment {
    get {
      if case .clientEnvironment(let v)? = _storage._category {return v}
      return FailureDetails_ClientEnvironment()
    }
    set {_uniqueStorage()._category = .clientEnvironment(newValue)}
  }

  public var crash: FailureDetails_Crash {
    get {
      if case .crash(let v)? = _storage._category {return v}
      return FailureDetails_Crash()
    }
    set {_uniqueStorage()._category = .crash(newValue)}
  }

  public var symlinkForest: FailureDetails_SymlinkForest {
    get {
      if case .symlinkForest(let v)? = _storage._category {return v}
      return FailureDetails_SymlinkForest()
    }
    set {_uniqueStorage()._category = .symlinkForest(newValue)}
  }

  public var packageOptions: FailureDetails_PackageOptions {
    get {
      if case .packageOptions(let v)? = _storage._category {return v}
      return FailureDetails_PackageOptions()
    }
    set {_uniqueStorage()._category = .packageOptions(newValue)}
  }

  public var remoteExecution: FailureDetails_RemoteExecution {
    get {
      if case .remoteExecution(let v)? = _storage._category {return v}
      return FailureDetails_RemoteExecution()
    }
    set {_uniqueStorage()._category = .remoteExecution(newValue)}
  }

  public var execution: FailureDetails_Execution {
    get {
      if case .execution(let v)? = _storage._category {return v}
      return FailureDetails_Execution()
    }
    set {_uniqueStorage()._category = .execution(newValue)}
  }

  public var workspaces: FailureDetails_Workspaces {
    get {
      if case .workspaces(let v)? = _storage._category {return v}
      return FailureDetails_Workspaces()
    }
    set {_uniqueStorage()._category = .workspaces(newValue)}
  }

  public var crashOptions: FailureDetails_CrashOptions {
    get {
      if case .crashOptions(let v)? = _storage._category {return v}
      return FailureDetails_CrashOptions()
    }
    set {_uniqueStorage()._category = .crashOptions(newValue)}
  }

  public var filesystem: FailureDetails_Filesystem {
    get {
      if case .filesystem(let v)? = _storage._category {return v}
      return FailureDetails_Filesystem()
    }
    set {_uniqueStorage()._category = .filesystem(newValue)}
  }

  public var executionOptions: FailureDetails_ExecutionOptions {
    get {
      if case .executionOptions(let v)? = _storage._category {return v}
      return FailureDetails_ExecutionOptions()
    }
    set {_uniqueStorage()._category = .executionOptions(newValue)}
  }

  public var command: FailureDetails_Command {
    get {
      if case .command(let v)? = _storage._category {return v}
      return FailureDetails_Command()
    }
    set {_uniqueStorage()._category = .command(newValue)}
  }

  public var spawn: FailureDetails_Spawn {
    get {
      if case .spawn(let v)? = _storage._category {return v}
      return FailureDetails_Spawn()
    }
    set {_uniqueStorage()._category = .spawn(newValue)}
  }

  public var grpcServer: FailureDetails_GrpcServer {
    get {
      if case .grpcServer(let v)? = _storage._category {return v}
      return FailureDetails_GrpcServer()
    }
    set {_uniqueStorage()._category = .grpcServer(newValue)}
  }

  public var canonicalizeFlags: FailureDetails_CanonicalizeFlags {
    get {
      if case .canonicalizeFlags(let v)? = _storage._category {return v}
      return FailureDetails_CanonicalizeFlags()
    }
    set {_uniqueStorage()._category = .canonicalizeFlags(newValue)}
  }

  public var buildConfiguration: FailureDetails_BuildConfiguration {
    get {
      if case .buildConfiguration(let v)? = _storage._category {return v}
      return FailureDetails_BuildConfiguration()
    }
    set {_uniqueStorage()._category = .buildConfiguration(newValue)}
  }

  public var infoCommand: FailureDetails_InfoCommand {
    get {
      if case .infoCommand(let v)? = _storage._category {return v}
      return FailureDetails_InfoCommand()
    }
    set {_uniqueStorage()._category = .infoCommand(newValue)}
  }

  public var memoryOptions: FailureDetails_MemoryOptions {
    get {
      if case .memoryOptions(let v)? = _storage._category {return v}
      return FailureDetails_MemoryOptions()
    }
    set {_uniqueStorage()._category = .memoryOptions(newValue)}
  }

  public var query: FailureDetails_Query {
    get {
      if case .query(let v)? = _storage._category {return v}
      return FailureDetails_Query()
    }
    set {_uniqueStorage()._category = .query(newValue)}
  }

  public var localExecution: FailureDetails_LocalExecution {
    get {
      if case .localExecution(let v)? = _storage._category {return v}
      return FailureDetails_LocalExecution()
    }
    set {_uniqueStorage()._category = .localExecution(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Category: Equatable {
    case interrupted(FailureDetails_Interrupted)
    case externalRepository(FailureDetails_ExternalRepository)
    case buildProgress(FailureDetails_BuildProgress)
    case remoteOptions(FailureDetails_RemoteOptions)
    case clientEnvironment(FailureDetails_ClientEnvironment)
    case crash(FailureDetails_Crash)
    case symlinkForest(FailureDetails_SymlinkForest)
    case packageOptions(FailureDetails_PackageOptions)
    case remoteExecution(FailureDetails_RemoteExecution)
    case execution(FailureDetails_Execution)
    case workspaces(FailureDetails_Workspaces)
    case crashOptions(FailureDetails_CrashOptions)
    case filesystem(FailureDetails_Filesystem)
    case executionOptions(FailureDetails_ExecutionOptions)
    case command(FailureDetails_Command)
    case spawn(FailureDetails_Spawn)
    case grpcServer(FailureDetails_GrpcServer)
    case canonicalizeFlags(FailureDetails_CanonicalizeFlags)
    case buildConfiguration(FailureDetails_BuildConfiguration)
    case infoCommand(FailureDetails_InfoCommand)
    case memoryOptions(FailureDetails_MemoryOptions)
    case query(FailureDetails_Query)
    case localExecution(FailureDetails_LocalExecution)

  #if !swift(>=4.1)
    public static func ==(lhs: FailureDetails_FailureDetail.OneOf_Category, rhs: FailureDetails_FailureDetail.OneOf_Category) -> Bool {
      switch (lhs, rhs) {
      case (.interrupted(let l), .interrupted(let r)): return l == r
      case (.externalRepository(let l), .externalRepository(let r)): return l == r
      case (.buildProgress(let l), .buildProgress(let r)): return l == r
      case (.remoteOptions(let l), .remoteOptions(let r)): return l == r
      case (.clientEnvironment(let l), .clientEnvironment(let r)): return l == r
      case (.crash(let l), .crash(let r)): return l == r
      case (.symlinkForest(let l), .symlinkForest(let r)): return l == r
      case (.packageOptions(let l), .packageOptions(let r)): return l == r
      case (.remoteExecution(let l), .remoteExecution(let r)): return l == r
      case (.execution(let l), .execution(let r)): return l == r
      case (.workspaces(let l), .workspaces(let r)): return l == r
      case (.crashOptions(let l), .crashOptions(let r)): return l == r
      case (.filesystem(let l), .filesystem(let r)): return l == r
      case (.executionOptions(let l), .executionOptions(let r)): return l == r
      case (.command(let l), .command(let r)): return l == r
      case (.spawn(let l), .spawn(let r)): return l == r
      case (.grpcServer(let l), .grpcServer(let r)): return l == r
      case (.canonicalizeFlags(let l), .canonicalizeFlags(let r)): return l == r
      case (.buildConfiguration(let l), .buildConfiguration(let r)): return l == r
      case (.infoCommand(let l), .infoCommand(let r)): return l == r
      case (.memoryOptions(let l), .memoryOptions(let r)): return l == r
      case (.query(let l), .query(let r)): return l == r
      case (.localExecution(let l), .localExecution(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FailureDetails_Interrupted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Interrupted.Code = .interruptedUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case interruptedUnknown // = 0
    case build // = 4
    case buildCompletion // = 5
    case packageLoadingSync // = 6
    case executorCompletion // = 7
    case commandDispatch // = 8
    case infoItem // = 9
    case afterQuery // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .interruptedUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .interruptedUnknown
      case 4: self = .build
      case 5: self = .buildCompletion
      case 6: self = .packageLoadingSync
      case 7: self = .executorCompletion
      case 8: self = .commandDispatch
      case 9: self = .infoItem
      case 10: self = .afterQuery
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .interruptedUnknown: return 0
      case .build: return 4
      case .buildCompletion: return 5
      case .packageLoadingSync: return 6
      case .executorCompletion: return 7
      case .commandDispatch: return 8
      case .infoItem: return 9
      case .afterQuery: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Interrupted.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Interrupted.Code] = [
    .interruptedUnknown,
    .build,
    .buildCompletion,
    .packageLoadingSync,
    .executorCompletion,
    .commandDispatch,
    .infoItem,
    .afterQuery,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Spawn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Spawn.Code = .spawnUnknown

  public var catastrophic: Bool = false

  public var spawnExitCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case spawnUnknown // = 0
    case nonZeroExit // = 1
    case timeout // = 2
    case outOfMemory // = 3
    case executionFailed // = 4
    case executionDenied // = 5
    case remoteCacheFailed // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .spawnUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .spawnUnknown
      case 1: self = .nonZeroExit
      case 2: self = .timeout
      case 3: self = .outOfMemory
      case 4: self = .executionFailed
      case 5: self = .executionDenied
      case 6: self = .remoteCacheFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .spawnUnknown: return 0
      case .nonZeroExit: return 1
      case .timeout: return 2
      case .outOfMemory: return 3
      case .executionFailed: return 4
      case .executionDenied: return 5
      case .remoteCacheFailed: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Spawn.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Spawn.Code] = [
    .spawnUnknown,
    .nonZeroExit,
    .timeout,
    .outOfMemory,
    .executionFailed,
    .executionDenied,
    .remoteCacheFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ExternalRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ExternalRepository.Code = .externalRepositoryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case externalRepositoryUnknown // = 0
    case overrideDisallowedManagedDirectories // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .externalRepositoryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .externalRepositoryUnknown
      case 1: self = .overrideDisallowedManagedDirectories
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .externalRepositoryUnknown: return 0
      case .overrideDisallowedManagedDirectories: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ExternalRepository.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ExternalRepository.Code] = [
    .externalRepositoryUnknown,
    .overrideDisallowedManagedDirectories,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_BuildProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_BuildProgress.Code = .buildProgressUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case buildProgressUnknown // = 0
    case outputInitialization // = 3
    case besRunsPerTestLimitUnsupported // = 4
    case besLocalWriteError // = 5
    case besInitializationError // = 6
    case besUploadTimeoutError // = 7
    case besFileWriteTimeout // = 8
    case besFileWriteIoError // = 9
    case besFileWriteInterrupted // = 10
    case besFileWriteCanceled // = 11
    case besFileWriteUnknownError // = 12
    case besUploadLocalFileError // = 13
    case besStreamNotRetryingFailure // = 14
    case besStreamCompletedWithUnackEventsError // = 15
    case besStreamCompletedWithUnsentEventsError // = 16
    case besUploadRetryLimitExceededFailure // = 17
    case UNRECOGNIZED(Int)

    public init() {
      self = .buildProgressUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buildProgressUnknown
      case 3: self = .outputInitialization
      case 4: self = .besRunsPerTestLimitUnsupported
      case 5: self = .besLocalWriteError
      case 6: self = .besInitializationError
      case 7: self = .besUploadTimeoutError
      case 8: self = .besFileWriteTimeout
      case 9: self = .besFileWriteIoError
      case 10: self = .besFileWriteInterrupted
      case 11: self = .besFileWriteCanceled
      case 12: self = .besFileWriteUnknownError
      case 13: self = .besUploadLocalFileError
      case 14: self = .besStreamNotRetryingFailure
      case 15: self = .besStreamCompletedWithUnackEventsError
      case 16: self = .besStreamCompletedWithUnsentEventsError
      case 17: self = .besUploadRetryLimitExceededFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .buildProgressUnknown: return 0
      case .outputInitialization: return 3
      case .besRunsPerTestLimitUnsupported: return 4
      case .besLocalWriteError: return 5
      case .besInitializationError: return 6
      case .besUploadTimeoutError: return 7
      case .besFileWriteTimeout: return 8
      case .besFileWriteIoError: return 9
      case .besFileWriteInterrupted: return 10
      case .besFileWriteCanceled: return 11
      case .besFileWriteUnknownError: return 12
      case .besUploadLocalFileError: return 13
      case .besStreamNotRetryingFailure: return 14
      case .besStreamCompletedWithUnackEventsError: return 15
      case .besStreamCompletedWithUnsentEventsError: return 16
      case .besUploadRetryLimitExceededFailure: return 17
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_BuildProgress.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_BuildProgress.Code] = [
    .buildProgressUnknown,
    .outputInitialization,
    .besRunsPerTestLimitUnsupported,
    .besLocalWriteError,
    .besInitializationError,
    .besUploadTimeoutError,
    .besFileWriteTimeout,
    .besFileWriteIoError,
    .besFileWriteInterrupted,
    .besFileWriteCanceled,
    .besFileWriteUnknownError,
    .besUploadLocalFileError,
    .besStreamNotRetryingFailure,
    .besStreamCompletedWithUnackEventsError,
    .besStreamCompletedWithUnsentEventsError,
    .besUploadRetryLimitExceededFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_RemoteOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_RemoteOptions.Code = .remoteOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case remoteOptionsUnknown // = 0
    case remoteDefaultExecPropertiesLogicError // = 1
    case credentialsReadFailure // = 2
    case credentialsWriteFailure // = 3
    case downloaderWithoutGrpcCache // = 4
    case executionWithInvalidCache // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .remoteOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .remoteOptionsUnknown
      case 1: self = .remoteDefaultExecPropertiesLogicError
      case 2: self = .credentialsReadFailure
      case 3: self = .credentialsWriteFailure
      case 4: self = .downloaderWithoutGrpcCache
      case 5: self = .executionWithInvalidCache
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .remoteOptionsUnknown: return 0
      case .remoteDefaultExecPropertiesLogicError: return 1
      case .credentialsReadFailure: return 2
      case .credentialsWriteFailure: return 3
      case .downloaderWithoutGrpcCache: return 4
      case .executionWithInvalidCache: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_RemoteOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_RemoteOptions.Code] = [
    .remoteOptionsUnknown,
    .remoteDefaultExecPropertiesLogicError,
    .credentialsReadFailure,
    .credentialsWriteFailure,
    .downloaderWithoutGrpcCache,
    .executionWithInvalidCache,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ClientEnvironment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ClientEnvironment.Code = .clientEnvironmentUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case clientEnvironmentUnknown // = 0
    case clientCwdMalformed // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .clientEnvironmentUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .clientEnvironmentUnknown
      case 1: self = .clientCwdMalformed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .clientEnvironmentUnknown: return 0
      case .clientCwdMalformed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ClientEnvironment.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ClientEnvironment.Code] = [
    .clientEnvironmentUnknown,
    .clientCwdMalformed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Crash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Crash.Code = .crashUnknown

  public var causes: [FailureDetails_Throwable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case crashUnknown // = 0
    case crashOom // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .crashUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .crashUnknown
      case 1: self = .crashOom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .crashUnknown: return 0
      case .crashOom: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Crash.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Crash.Code] = [
    .crashUnknown,
    .crashOom,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Throwable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var throwableClass: String = String()

  public var message: String = String()

  public var stackTrace: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FailureDetails_SymlinkForest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_SymlinkForest.Code = .symlinkForestUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case symlinkForestUnknown // = 0
    case toplevelOutdirPackagePathConflict // = 1
    case toplevelOutdirUsedAsSource // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .symlinkForestUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .symlinkForestUnknown
      case 1: self = .toplevelOutdirPackagePathConflict
      case 2: self = .toplevelOutdirUsedAsSource
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .symlinkForestUnknown: return 0
      case .toplevelOutdirPackagePathConflict: return 1
      case .toplevelOutdirUsedAsSource: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_SymlinkForest.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_SymlinkForest.Code] = [
    .symlinkForestUnknown,
    .toplevelOutdirPackagePathConflict,
    .toplevelOutdirUsedAsSource,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_PackageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_PackageOptions.Code = .packageOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case packageOptionsUnknown // = 0
    case packagePathInvalid // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .packageOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .packageOptionsUnknown
      case 1: self = .packagePathInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .packageOptionsUnknown: return 0
      case .packagePathInvalid: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_PackageOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_PackageOptions.Code] = [
    .packageOptionsUnknown,
    .packagePathInvalid,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_RemoteExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_RemoteExecution.Code = .remoteExecutionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case remoteExecutionUnknown // = 0
    case capabilitiesQueryFailure // = 1
    case credentialsInitFailure // = 2
    case cacheInitFailure // = 3
    case rpcLogFailure // = 4
    case execChannelInitFailure // = 5
    case cacheChannelInitFailure // = 6
    case downloaderChannelInitFailure // = 7
    case logDirCleanupFailure // = 8
    case clientServerIncompatible // = 9
    case downloadedInputsDeletionFailure // = 10
    case remoteDownloadOutputsMinimalWithoutInmemoryDotd // = 11
    case remoteDownloadOutputsMinimalWithoutInmemoryJdeps // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .remoteExecutionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .remoteExecutionUnknown
      case 1: self = .capabilitiesQueryFailure
      case 2: self = .credentialsInitFailure
      case 3: self = .cacheInitFailure
      case 4: self = .rpcLogFailure
      case 5: self = .execChannelInitFailure
      case 6: self = .cacheChannelInitFailure
      case 7: self = .downloaderChannelInitFailure
      case 8: self = .logDirCleanupFailure
      case 9: self = .clientServerIncompatible
      case 10: self = .downloadedInputsDeletionFailure
      case 11: self = .remoteDownloadOutputsMinimalWithoutInmemoryDotd
      case 12: self = .remoteDownloadOutputsMinimalWithoutInmemoryJdeps
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .remoteExecutionUnknown: return 0
      case .capabilitiesQueryFailure: return 1
      case .credentialsInitFailure: return 2
      case .cacheInitFailure: return 3
      case .rpcLogFailure: return 4
      case .execChannelInitFailure: return 5
      case .cacheChannelInitFailure: return 6
      case .downloaderChannelInitFailure: return 7
      case .logDirCleanupFailure: return 8
      case .clientServerIncompatible: return 9
      case .downloadedInputsDeletionFailure: return 10
      case .remoteDownloadOutputsMinimalWithoutInmemoryDotd: return 11
      case .remoteDownloadOutputsMinimalWithoutInmemoryJdeps: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_RemoteExecution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_RemoteExecution.Code] = [
    .remoteExecutionUnknown,
    .capabilitiesQueryFailure,
    .credentialsInitFailure,
    .cacheInitFailure,
    .rpcLogFailure,
    .execChannelInitFailure,
    .cacheChannelInitFailure,
    .downloaderChannelInitFailure,
    .logDirCleanupFailure,
    .clientServerIncompatible,
    .downloadedInputsDeletionFailure,
    .remoteDownloadOutputsMinimalWithoutInmemoryDotd,
    .remoteDownloadOutputsMinimalWithoutInmemoryJdeps,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Execution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Execution.Code = .executionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case executionUnknown // = 0
    case executionLogInitializationFailure // = 1
    case executionLogWriteFailure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .executionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .executionUnknown
      case 1: self = .executionLogInitializationFailure
      case 2: self = .executionLogWriteFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .executionUnknown: return 0
      case .executionLogInitializationFailure: return 1
      case .executionLogWriteFailure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Execution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Execution.Code] = [
    .executionUnknown,
    .executionLogInitializationFailure,
    .executionLogWriteFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Workspaces {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Workspaces.Code = .workspacesUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workspacesUnknown // = 0
    case workspacesLogInitializationFailure // = 1
    case workspacesLogWriteFailure // = 2
    case illegalWorkspaceFileSymlinkWithManagedDirectories // = 3
    case workspaceFileReadFailureWithManagedDirectories // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .workspacesUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workspacesUnknown
      case 1: self = .workspacesLogInitializationFailure
      case 2: self = .workspacesLogWriteFailure
      case 3: self = .illegalWorkspaceFileSymlinkWithManagedDirectories
      case 4: self = .workspaceFileReadFailureWithManagedDirectories
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workspacesUnknown: return 0
      case .workspacesLogInitializationFailure: return 1
      case .workspacesLogWriteFailure: return 2
      case .illegalWorkspaceFileSymlinkWithManagedDirectories: return 3
      case .workspaceFileReadFailureWithManagedDirectories: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Workspaces.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Workspaces.Code] = [
    .workspacesUnknown,
    .workspacesLogInitializationFailure,
    .workspacesLogWriteFailure,
    .illegalWorkspaceFileSymlinkWithManagedDirectories,
    .workspaceFileReadFailureWithManagedDirectories,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CrashOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CrashOptions.Code = .crashOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case crashOptionsUnknown // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .crashOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .crashOptionsUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .crashOptionsUnknown: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CrashOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CrashOptions.Code] = [
    .crashOptionsUnknown,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Filesystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Filesystem.Code = .filesystemUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case filesystemUnknown // = 0
    case defaultDigestHashFunctionChanged // = 1
    case defaultDigestHashFunctionNotSet // = 2
    case embeddedBinariesEnumerationFailure // = 3
    case serverPidTxtFileReadFailure // = 4
    case serverFileWriteFailure // = 5
    case defaultDigestHashFunctionInvalidValue // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .filesystemUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .filesystemUnknown
      case 1: self = .defaultDigestHashFunctionChanged
      case 2: self = .defaultDigestHashFunctionNotSet
      case 3: self = .embeddedBinariesEnumerationFailure
      case 4: self = .serverPidTxtFileReadFailure
      case 5: self = .serverFileWriteFailure
      case 6: self = .defaultDigestHashFunctionInvalidValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .filesystemUnknown: return 0
      case .defaultDigestHashFunctionChanged: return 1
      case .defaultDigestHashFunctionNotSet: return 2
      case .embeddedBinariesEnumerationFailure: return 3
      case .serverPidTxtFileReadFailure: return 4
      case .serverFileWriteFailure: return 5
      case .defaultDigestHashFunctionInvalidValue: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Filesystem.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Filesystem.Code] = [
    .filesystemUnknown,
    .defaultDigestHashFunctionChanged,
    .defaultDigestHashFunctionNotSet,
    .embeddedBinariesEnumerationFailure,
    .serverPidTxtFileReadFailure,
    .serverFileWriteFailure,
    .defaultDigestHashFunctionInvalidValue,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ExecutionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ExecutionOptions.Code = .executionOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case executionOptionsUnknown // = 0
    case invalidStrategy // = 3
    case requestedStrategyIncompatibleWithSandboxing // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .executionOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .executionOptionsUnknown
      case 3: self = .invalidStrategy
      case 4: self = .requestedStrategyIncompatibleWithSandboxing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .executionOptionsUnknown: return 0
      case .invalidStrategy: return 3
      case .requestedStrategyIncompatibleWithSandboxing: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ExecutionOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ExecutionOptions.Code] = [
    .executionOptionsUnknown,
    .invalidStrategy,
    .requestedStrategyIncompatibleWithSandboxing,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Command.Code = .commandFailureUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case commandFailureUnknown // = 0
    case commandNotFound // = 1
    case anotherCommandRunning // = 2
    case previouslyShutdown // = 3
    case starlarkCpuProfileFileInitializationFailure // = 4
    case starlarkCpuProfilingInitializationFailure // = 5
    case starlarkCpuProfileFileWriteFailure // = 6
    case invocationPolicyParseFailure // = 7
    case invocationPolicyInvalid // = 8
    case optionsParseFailure // = 9
    case starlarkOptionsParseFailure // = 10
    case argumentsNotRecognized // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .commandFailureUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .commandFailureUnknown
      case 1: self = .commandNotFound
      case 2: self = .anotherCommandRunning
      case 3: self = .previouslyShutdown
      case 4: self = .starlarkCpuProfileFileInitializationFailure
      case 5: self = .starlarkCpuProfilingInitializationFailure
      case 6: self = .starlarkCpuProfileFileWriteFailure
      case 7: self = .invocationPolicyParseFailure
      case 8: self = .invocationPolicyInvalid
      case 9: self = .optionsParseFailure
      case 10: self = .starlarkOptionsParseFailure
      case 11: self = .argumentsNotRecognized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .commandFailureUnknown: return 0
      case .commandNotFound: return 1
      case .anotherCommandRunning: return 2
      case .previouslyShutdown: return 3
      case .starlarkCpuProfileFileInitializationFailure: return 4
      case .starlarkCpuProfilingInitializationFailure: return 5
      case .starlarkCpuProfileFileWriteFailure: return 6
      case .invocationPolicyParseFailure: return 7
      case .invocationPolicyInvalid: return 8
      case .optionsParseFailure: return 9
      case .starlarkOptionsParseFailure: return 10
      case .argumentsNotRecognized: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Command.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Command.Code] = [
    .commandFailureUnknown,
    .commandNotFound,
    .anotherCommandRunning,
    .previouslyShutdown,
    .starlarkCpuProfileFileInitializationFailure,
    .starlarkCpuProfilingInitializationFailure,
    .starlarkCpuProfileFileWriteFailure,
    .invocationPolicyParseFailure,
    .invocationPolicyInvalid,
    .optionsParseFailure,
    .starlarkOptionsParseFailure,
    .argumentsNotRecognized,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_GrpcServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_GrpcServer.Code = .grpcServerUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case grpcServerUnknown // = 0
    case grpcServerNotCompiledIn // = 1
    case serverBindFailure // = 2
    case badCookie // = 3
    case noClientDescription // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .grpcServerUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .grpcServerUnknown
      case 1: self = .grpcServerNotCompiledIn
      case 2: self = .serverBindFailure
      case 3: self = .badCookie
      case 4: self = .noClientDescription
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .grpcServerUnknown: return 0
      case .grpcServerNotCompiledIn: return 1
      case .serverBindFailure: return 2
      case .badCookie: return 3
      case .noClientDescription: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_GrpcServer.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_GrpcServer.Code] = [
    .grpcServerUnknown,
    .grpcServerNotCompiledIn,
    .serverBindFailure,
    .badCookie,
    .noClientDescription,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CanonicalizeFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CanonicalizeFlags.Code = .canonicalizeFlagsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case canonicalizeFlagsUnknown // = 0
    case forCommandInvalid // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .canonicalizeFlagsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .canonicalizeFlagsUnknown
      case 1: self = .forCommandInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .canonicalizeFlagsUnknown: return 0
      case .forCommandInvalid: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CanonicalizeFlags.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CanonicalizeFlags.Code] = [
    .canonicalizeFlagsUnknown,
    .forCommandInvalid,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_BuildConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_BuildConfiguration.Code = .buildConfigurationUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case buildConfigurationUnknown // = 0
    case platformMappingEvaluationFailure // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .buildConfigurationUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buildConfigurationUnknown
      case 1: self = .platformMappingEvaluationFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .buildConfigurationUnknown: return 0
      case .platformMappingEvaluationFailure: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_BuildConfiguration.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_BuildConfiguration.Code] = [
    .buildConfigurationUnknown,
    .platformMappingEvaluationFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_InfoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_InfoCommand.Code = .infoCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case infoCommandUnknown // = 0
    case tooManyKeys // = 1
    case keyNotRecognized // = 2
    case infoBlockWriteFailure // = 3
    case allInfoWriteFailure // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .infoCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .infoCommandUnknown
      case 1: self = .tooManyKeys
      case 2: self = .keyNotRecognized
      case 3: self = .infoBlockWriteFailure
      case 4: self = .allInfoWriteFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .infoCommandUnknown: return 0
      case .tooManyKeys: return 1
      case .keyNotRecognized: return 2
      case .infoBlockWriteFailure: return 3
      case .allInfoWriteFailure: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_InfoCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_InfoCommand.Code] = [
    .infoCommandUnknown,
    .tooManyKeys,
    .keyNotRecognized,
    .infoBlockWriteFailure,
    .allInfoWriteFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_MemoryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_MemoryOptions.Code = .memoryOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case memoryOptionsUnknown // = 0
    case experimentalOomMoreEagerlyThresholdInvalidValue // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .memoryOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .memoryOptionsUnknown
      case 1: self = .experimentalOomMoreEagerlyThresholdInvalidValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .memoryOptionsUnknown: return 0
      case .experimentalOomMoreEagerlyThresholdInvalidValue: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_MemoryOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_MemoryOptions.Code] = [
    .memoryOptionsUnknown,
    .experimentalOomMoreEagerlyThresholdInvalidValue,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Query.Code = .queryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case queryUnknown // = 0
    case queryFileWithCommandLineExpression // = 1
    case queryFileReadFailure // = 2
    case commandLineExpressionMissing // = 3
    case outputFormatInvalid // = 4
    case graphlessPrereqUnmet // = 5
    case queryOutputWriteFailure // = 6
    case queryStdoutFlushFailure // = 13
    case analysisQueryPrereqUnmet // = 14
    case UNRECOGNIZED(Int)

    public init() {
      self = .queryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .queryUnknown
      case 1: self = .queryFileWithCommandLineExpression
      case 2: self = .queryFileReadFailure
      case 3: self = .commandLineExpressionMissing
      case 4: self = .outputFormatInvalid
      case 5: self = .graphlessPrereqUnmet
      case 6: self = .queryOutputWriteFailure
      case 13: self = .queryStdoutFlushFailure
      case 14: self = .analysisQueryPrereqUnmet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .queryUnknown: return 0
      case .queryFileWithCommandLineExpression: return 1
      case .queryFileReadFailure: return 2
      case .commandLineExpressionMissing: return 3
      case .outputFormatInvalid: return 4
      case .graphlessPrereqUnmet: return 5
      case .queryOutputWriteFailure: return 6
      case .queryStdoutFlushFailure: return 13
      case .analysisQueryPrereqUnmet: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Query.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Query.Code] = [
    .queryUnknown,
    .queryFileWithCommandLineExpression,
    .queryFileReadFailure,
    .commandLineExpressionMissing,
    .outputFormatInvalid,
    .graphlessPrereqUnmet,
    .queryOutputWriteFailure,
    .queryStdoutFlushFailure,
    .analysisQueryPrereqUnmet,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_LocalExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_LocalExecution.Code = .localExecutionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case localExecutionUnknown // = 0
    case lockfreeOutputPrereqUnmet // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .localExecutionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .localExecutionUnknown
      case 1: self = .lockfreeOutputPrereqUnmet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .localExecutionUnknown: return 0
      case .lockfreeOutputPrereqUnmet: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_LocalExecution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_LocalExecution.Code] = [
    .localExecutionUnknown,
    .lockfreeOutputPrereqUnmet,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Extension support defined in failure_details.proto.

extension SwiftProtobuf.Google_Protobuf_EnumValueOptions {

  public var FailureDetails_metadata: FailureDetails_FailureDetailMetadata {
    get {return getExtensionValue(ext: FailureDetails_Extensions_metadata) ?? FailureDetails_FailureDetailMetadata()}
    set {setExtensionValue(ext: FailureDetails_Extensions_metadata, value: newValue)}
  }
  /// Returns true if extension `FailureDetails_Extensions_metadata`
  /// has been explicitly set.
  public var hasFailureDetails_metadata: Bool {
    return hasExtensionValue(ext: FailureDetails_Extensions_metadata)
  }
  /// Clears the value of extension `FailureDetails_Extensions_metadata`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearFailureDetails_metadata() {
    clearExtensionValue(ext: FailureDetails_Extensions_metadata)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let FailureDetails_FailureDetails_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  FailureDetails_Extensions_metadata
]

let FailureDetails_Extensions_metadata = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<FailureDetails_FailureDetailMetadata>, SwiftProtobuf.Google_Protobuf_EnumValueOptions>(
  _protobuf_fieldNumber: 1078,
  fieldName: "failure_details.metadata"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "failure_details"

extension FailureDetails_FailureDetailMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailureDetailMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.exitCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exitCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.exitCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FailureDetailMetadata, rhs: FailureDetails_FailureDetailMetadata) -> Bool {
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_FailureDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailureDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    101: .same(proto: "interrupted"),
    103: .standard(proto: "external_repository"),
    104: .standard(proto: "build_progress"),
    106: .standard(proto: "remote_options"),
    107: .standard(proto: "client_environment"),
    108: .same(proto: "crash"),
    110: .standard(proto: "symlink_forest"),
    114: .standard(proto: "package_options"),
    115: .standard(proto: "remote_execution"),
    116: .same(proto: "execution"),
    117: .same(proto: "workspaces"),
    118: .standard(proto: "crash_options"),
    119: .same(proto: "filesystem"),
    121: .standard(proto: "execution_options"),
    122: .same(proto: "command"),
    123: .same(proto: "spawn"),
    124: .standard(proto: "grpc_server"),
    125: .standard(proto: "canonicalize_flags"),
    126: .standard(proto: "build_configuration"),
    127: .standard(proto: "info_command"),
    129: .standard(proto: "memory_options"),
    130: .same(proto: "query"),
    132: .standard(proto: "local_execution"),
  ]

  fileprivate class _StorageClass {
    var _message: String = String()
    var _category: FailureDetails_FailureDetail.OneOf_Category?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _category = source._category
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._message)
        case 101:
          var v: FailureDetails_Interrupted?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .interrupted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .interrupted(v)}
        case 103:
          var v: FailureDetails_ExternalRepository?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .externalRepository(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .externalRepository(v)}
        case 104:
          var v: FailureDetails_BuildProgress?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .buildProgress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .buildProgress(v)}
        case 106:
          var v: FailureDetails_RemoteOptions?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .remoteOptions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .remoteOptions(v)}
        case 107:
          var v: FailureDetails_ClientEnvironment?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .clientEnvironment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .clientEnvironment(v)}
        case 108:
          var v: FailureDetails_Crash?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .crash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .crash(v)}
        case 110:
          var v: FailureDetails_SymlinkForest?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .symlinkForest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .symlinkForest(v)}
        case 114:
          var v: FailureDetails_PackageOptions?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .packageOptions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .packageOptions(v)}
        case 115:
          var v: FailureDetails_RemoteExecution?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .remoteExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .remoteExecution(v)}
        case 116:
          var v: FailureDetails_Execution?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .execution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .execution(v)}
        case 117:
          var v: FailureDetails_Workspaces?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .workspaces(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .workspaces(v)}
        case 118:
          var v: FailureDetails_CrashOptions?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .crashOptions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .crashOptions(v)}
        case 119:
          var v: FailureDetails_Filesystem?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .filesystem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .filesystem(v)}
        case 121:
          var v: FailureDetails_ExecutionOptions?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .executionOptions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .executionOptions(v)}
        case 122:
          var v: FailureDetails_Command?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .command(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .command(v)}
        case 123:
          var v: FailureDetails_Spawn?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .spawn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .spawn(v)}
        case 124:
          var v: FailureDetails_GrpcServer?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .grpcServer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .grpcServer(v)}
        case 125:
          var v: FailureDetails_CanonicalizeFlags?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .canonicalizeFlags(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .canonicalizeFlags(v)}
        case 126:
          var v: FailureDetails_BuildConfiguration?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .buildConfiguration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .buildConfiguration(v)}
        case 127:
          var v: FailureDetails_InfoCommand?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .infoCommand(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .infoCommand(v)}
        case 129:
          var v: FailureDetails_MemoryOptions?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .memoryOptions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .memoryOptions(v)}
        case 130:
          var v: FailureDetails_Query?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .query(v)}
        case 132:
          var v: FailureDetails_LocalExecution?
          if let current = _storage._category {
            try decoder.handleConflictingOneOf()
            if case .localExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._category = .localExecution(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 1)
      }
      switch _storage._category {
      case .interrupted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      case .externalRepository(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      case .buildProgress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      case .remoteOptions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      case .clientEnvironment(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
      case .crash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      case .symlinkForest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
      case .packageOptions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
      case .remoteExecution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
      case .execution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
      case .workspaces(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
      case .crashOptions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
      case .filesystem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
      case .executionOptions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
      case .command(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
      case .spawn(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
      case .grpcServer(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
      case .canonicalizeFlags(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
      case .buildConfiguration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
      case .infoCommand(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
      case .memoryOptions(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
      case .query(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
      case .localExecution(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FailureDetail, rhs: FailureDetails_FailureDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._category != rhs_storage._category {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Interrupted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Interrupted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .interruptedUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Interrupted, rhs: FailureDetails_Interrupted) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Interrupted.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERRUPTED_UNKNOWN"),
    4: .same(proto: "BUILD"),
    5: .same(proto: "BUILD_COMPLETION"),
    6: .same(proto: "PACKAGE_LOADING_SYNC"),
    7: .same(proto: "EXECUTOR_COMPLETION"),
    8: .same(proto: "COMMAND_DISPATCH"),
    9: .same(proto: "INFO_ITEM"),
    10: .same(proto: "AFTER_QUERY"),
  ]
}

extension FailureDetails_Spawn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Spawn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "catastrophic"),
    3: .standard(proto: "spawn_exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularBoolField(value: &self.catastrophic)
      case 3: try decoder.decodeSingularInt32Field(value: &self.spawnExitCode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .spawnUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if self.catastrophic != false {
      try visitor.visitSingularBoolField(value: self.catastrophic, fieldNumber: 2)
    }
    if self.spawnExitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.spawnExitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Spawn, rhs: FailureDetails_Spawn) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.catastrophic != rhs.catastrophic {return false}
    if lhs.spawnExitCode != rhs.spawnExitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Spawn.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAWN_UNKNOWN"),
    1: .same(proto: "NON_ZERO_EXIT"),
    2: .same(proto: "TIMEOUT"),
    3: .same(proto: "OUT_OF_MEMORY"),
    4: .same(proto: "EXECUTION_FAILED"),
    5: .same(proto: "EXECUTION_DENIED"),
    6: .same(proto: "REMOTE_CACHE_FAILED"),
  ]
}

extension FailureDetails_ExternalRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .externalRepositoryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ExternalRepository, rhs: FailureDetails_ExternalRepository) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ExternalRepository.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNAL_REPOSITORY_UNKNOWN"),
    1: .same(proto: "OVERRIDE_DISALLOWED_MANAGED_DIRECTORIES"),
  ]
}

extension FailureDetails_BuildProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .buildProgressUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_BuildProgress, rhs: FailureDetails_BuildProgress) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_BuildProgress.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILD_PROGRESS_UNKNOWN"),
    3: .same(proto: "OUTPUT_INITIALIZATION"),
    4: .same(proto: "BES_RUNS_PER_TEST_LIMIT_UNSUPPORTED"),
    5: .same(proto: "BES_LOCAL_WRITE_ERROR"),
    6: .same(proto: "BES_INITIALIZATION_ERROR"),
    7: .same(proto: "BES_UPLOAD_TIMEOUT_ERROR"),
    8: .same(proto: "BES_FILE_WRITE_TIMEOUT"),
    9: .same(proto: "BES_FILE_WRITE_IO_ERROR"),
    10: .same(proto: "BES_FILE_WRITE_INTERRUPTED"),
    11: .same(proto: "BES_FILE_WRITE_CANCELED"),
    12: .same(proto: "BES_FILE_WRITE_UNKNOWN_ERROR"),
    13: .same(proto: "BES_UPLOAD_LOCAL_FILE_ERROR"),
    14: .same(proto: "BES_STREAM_NOT_RETRYING_FAILURE"),
    15: .same(proto: "BES_STREAM_COMPLETED_WITH_UNACK_EVENTS_ERROR"),
    16: .same(proto: "BES_STREAM_COMPLETED_WITH_UNSENT_EVENTS_ERROR"),
    17: .same(proto: "BES_UPLOAD_RETRY_LIMIT_EXCEEDED_FAILURE"),
  ]
}

extension FailureDetails_RemoteOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .remoteOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_RemoteOptions, rhs: FailureDetails_RemoteOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_RemoteOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REMOTE_OPTIONS_UNKNOWN"),
    1: .same(proto: "REMOTE_DEFAULT_EXEC_PROPERTIES_LOGIC_ERROR"),
    2: .same(proto: "CREDENTIALS_READ_FAILURE"),
    3: .same(proto: "CREDENTIALS_WRITE_FAILURE"),
    4: .same(proto: "DOWNLOADER_WITHOUT_GRPC_CACHE"),
    5: .same(proto: "EXECUTION_WITH_INVALID_CACHE"),
  ]
}

extension FailureDetails_ClientEnvironment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEnvironment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .clientEnvironmentUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ClientEnvironment, rhs: FailureDetails_ClientEnvironment) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ClientEnvironment.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT_ENVIRONMENT_UNKNOWN"),
    1: .same(proto: "CLIENT_CWD_MALFORMED"),
  ]
}

extension FailureDetails_Crash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Crash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "causes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.causes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .crashUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.causes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.causes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Crash, rhs: FailureDetails_Crash) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.causes != rhs.causes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Crash.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRASH_UNKNOWN"),
    1: .same(proto: "CRASH_OOM"),
  ]
}

extension FailureDetails_Throwable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Throwable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "throwable_class"),
    2: .same(proto: "message"),
    3: .standard(proto: "stack_trace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.throwableClass)
      case 2: try decoder.decodeSingularStringField(value: &self.message)
      case 3: try decoder.decodeRepeatedStringField(value: &self.stackTrace)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.throwableClass.isEmpty {
      try visitor.visitSingularStringField(value: self.throwableClass, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stackTrace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Throwable, rhs: FailureDetails_Throwable) -> Bool {
    if lhs.throwableClass != rhs.throwableClass {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SymlinkForest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymlinkForest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .symlinkForestUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_SymlinkForest, rhs: FailureDetails_SymlinkForest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SymlinkForest.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYMLINK_FOREST_UNKNOWN"),
    1: .same(proto: "TOPLEVEL_OUTDIR_PACKAGE_PATH_CONFLICT"),
    2: .same(proto: "TOPLEVEL_OUTDIR_USED_AS_SOURCE"),
  ]
}

extension FailureDetails_PackageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .packageOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_PackageOptions, rhs: FailureDetails_PackageOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_PackageOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PACKAGE_OPTIONS_UNKNOWN"),
    1: .same(proto: "PACKAGE_PATH_INVALID"),
  ]
}

extension FailureDetails_RemoteExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteExecution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .remoteExecutionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_RemoteExecution, rhs: FailureDetails_RemoteExecution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_RemoteExecution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REMOTE_EXECUTION_UNKNOWN"),
    1: .same(proto: "CAPABILITIES_QUERY_FAILURE"),
    2: .same(proto: "CREDENTIALS_INIT_FAILURE"),
    3: .same(proto: "CACHE_INIT_FAILURE"),
    4: .same(proto: "RPC_LOG_FAILURE"),
    5: .same(proto: "EXEC_CHANNEL_INIT_FAILURE"),
    6: .same(proto: "CACHE_CHANNEL_INIT_FAILURE"),
    7: .same(proto: "DOWNLOADER_CHANNEL_INIT_FAILURE"),
    8: .same(proto: "LOG_DIR_CLEANUP_FAILURE"),
    9: .same(proto: "CLIENT_SERVER_INCOMPATIBLE"),
    10: .same(proto: "DOWNLOADED_INPUTS_DELETION_FAILURE"),
    11: .same(proto: "REMOTE_DOWNLOAD_OUTPUTS_MINIMAL_WITHOUT_INMEMORY_DOTD"),
    12: .same(proto: "REMOTE_DOWNLOAD_OUTPUTS_MINIMAL_WITHOUT_INMEMORY_JDEPS"),
  ]
}

extension FailureDetails_Execution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Execution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .executionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Execution, rhs: FailureDetails_Execution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Execution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTION_UNKNOWN"),
    1: .same(proto: "EXECUTION_LOG_INITIALIZATION_FAILURE"),
    2: .same(proto: "EXECUTION_LOG_WRITE_FAILURE"),
  ]
}

extension FailureDetails_Workspaces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workspaces"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .workspacesUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Workspaces, rhs: FailureDetails_Workspaces) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Workspaces.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKSPACES_UNKNOWN"),
    1: .same(proto: "WORKSPACES_LOG_INITIALIZATION_FAILURE"),
    2: .same(proto: "WORKSPACES_LOG_WRITE_FAILURE"),
    3: .same(proto: "ILLEGAL_WORKSPACE_FILE_SYMLINK_WITH_MANAGED_DIRECTORIES"),
    4: .same(proto: "WORKSPACE_FILE_READ_FAILURE_WITH_MANAGED_DIRECTORIES"),
  ]
}

extension FailureDetails_CrashOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CrashOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .crashOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CrashOptions, rhs: FailureDetails_CrashOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CrashOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRASH_OPTIONS_UNKNOWN"),
  ]
}

extension FailureDetails_Filesystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filesystem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .filesystemUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Filesystem, rhs: FailureDetails_Filesystem) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Filesystem.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILESYSTEM_UNKNOWN"),
    1: .same(proto: "DEFAULT_DIGEST_HASH_FUNCTION_CHANGED"),
    2: .same(proto: "DEFAULT_DIGEST_HASH_FUNCTION_NOT_SET"),
    3: .same(proto: "EMBEDDED_BINARIES_ENUMERATION_FAILURE"),
    4: .same(proto: "SERVER_PID_TXT_FILE_READ_FAILURE"),
    5: .same(proto: "SERVER_FILE_WRITE_FAILURE"),
    6: .same(proto: "DEFAULT_DIGEST_HASH_FUNCTION_INVALID_VALUE"),
  ]
}

extension FailureDetails_ExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .executionOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ExecutionOptions, rhs: FailureDetails_ExecutionOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ExecutionOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTION_OPTIONS_UNKNOWN"),
    3: .same(proto: "INVALID_STRATEGY"),
    4: .same(proto: "REQUESTED_STRATEGY_INCOMPATIBLE_WITH_SANDBOXING"),
  ]
}

extension FailureDetails_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .commandFailureUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Command, rhs: FailureDetails_Command) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Command.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_FAILURE_UNKNOWN"),
    1: .same(proto: "COMMAND_NOT_FOUND"),
    2: .same(proto: "ANOTHER_COMMAND_RUNNING"),
    3: .same(proto: "PREVIOUSLY_SHUTDOWN"),
    4: .same(proto: "STARLARK_CPU_PROFILE_FILE_INITIALIZATION_FAILURE"),
    5: .same(proto: "STARLARK_CPU_PROFILING_INITIALIZATION_FAILURE"),
    6: .same(proto: "STARLARK_CPU_PROFILE_FILE_WRITE_FAILURE"),
    7: .same(proto: "INVOCATION_POLICY_PARSE_FAILURE"),
    8: .same(proto: "INVOCATION_POLICY_INVALID"),
    9: .same(proto: "OPTIONS_PARSE_FAILURE"),
    10: .same(proto: "STARLARK_OPTIONS_PARSE_FAILURE"),
    11: .same(proto: "ARGUMENTS_NOT_RECOGNIZED"),
  ]
}

extension FailureDetails_GrpcServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .grpcServerUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_GrpcServer, rhs: FailureDetails_GrpcServer) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_GrpcServer.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRPC_SERVER_UNKNOWN"),
    1: .same(proto: "GRPC_SERVER_NOT_COMPILED_IN"),
    2: .same(proto: "SERVER_BIND_FAILURE"),
    3: .same(proto: "BAD_COOKIE"),
    4: .same(proto: "NO_CLIENT_DESCRIPTION"),
  ]
}

extension FailureDetails_CanonicalizeFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanonicalizeFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .canonicalizeFlagsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CanonicalizeFlags, rhs: FailureDetails_CanonicalizeFlags) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CanonicalizeFlags.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANONICALIZE_FLAGS_UNKNOWN"),
    1: .same(proto: "FOR_COMMAND_INVALID"),
  ]
}

extension FailureDetails_BuildConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .buildConfigurationUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_BuildConfiguration, rhs: FailureDetails_BuildConfiguration) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_BuildConfiguration.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILD_CONFIGURATION_UNKNOWN"),
    1: .same(proto: "PLATFORM_MAPPING_EVALUATION_FAILURE"),
  ]
}

extension FailureDetails_InfoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .infoCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_InfoCommand, rhs: FailureDetails_InfoCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_InfoCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO_COMMAND_UNKNOWN"),
    1: .same(proto: "TOO_MANY_KEYS"),
    2: .same(proto: "KEY_NOT_RECOGNIZED"),
    3: .same(proto: "INFO_BLOCK_WRITE_FAILURE"),
    4: .same(proto: "ALL_INFO_WRITE_FAILURE"),
  ]
}

extension FailureDetails_MemoryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemoryOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .memoryOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_MemoryOptions, rhs: FailureDetails_MemoryOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_MemoryOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMORY_OPTIONS_UNKNOWN"),
    1: .same(proto: "EXPERIMENTAL_OOM_MORE_EAGERLY_THRESHOLD_INVALID_VALUE"),
  ]
}

extension FailureDetails_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .queryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Query, rhs: FailureDetails_Query) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Query.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUERY_UNKNOWN"),
    1: .same(proto: "QUERY_FILE_WITH_COMMAND_LINE_EXPRESSION"),
    2: .same(proto: "QUERY_FILE_READ_FAILURE"),
    3: .same(proto: "COMMAND_LINE_EXPRESSION_MISSING"),
    4: .same(proto: "OUTPUT_FORMAT_INVALID"),
    5: .same(proto: "GRAPHLESS_PREREQ_UNMET"),
    6: .same(proto: "QUERY_OUTPUT_WRITE_FAILURE"),
    13: .same(proto: "QUERY_STDOUT_FLUSH_FAILURE"),
    14: .same(proto: "ANALYSIS_QUERY_PREREQ_UNMET"),
  ]
}

extension FailureDetails_LocalExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalExecution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .localExecutionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_LocalExecution, rhs: FailureDetails_LocalExecution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_LocalExecution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCAL_EXECUTION_UNKNOWN"),
    1: .same(proto: "LOCKFREE_OUTPUT_PREREQ_UNMET"),
  ]
}
