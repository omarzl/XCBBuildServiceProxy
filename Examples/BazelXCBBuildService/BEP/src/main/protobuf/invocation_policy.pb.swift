// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/invocation_policy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Blaze_InvocationPolicy_InvocationPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flagPolicies: [Blaze_InvocationPolicy_FlagPolicy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Blaze_InvocationPolicy_FlagPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flagName: String {
    get {return _storage._flagName ?? String()}
    set {_uniqueStorage()._flagName = newValue}
  }
  /// Returns true if `flagName` has been explicitly set.
  public var hasFlagName: Bool {return _storage._flagName != nil}
  /// Clears the value of `flagName`. Subsequent reads from it will return its default value.
  public mutating func clearFlagName() {_uniqueStorage()._flagName = nil}

  public var commands: [String] {
    get {return _storage._commands}
    set {_uniqueStorage()._commands = newValue}
  }

  public var operation: OneOf_Operation? {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  public var setValue: Blaze_InvocationPolicy_SetValue {
    get {
      if case .setValue(let v)? = _storage._operation {return v}
      return Blaze_InvocationPolicy_SetValue()
    }
    set {_uniqueStorage()._operation = .setValue(newValue)}
  }

  public var useDefault: Blaze_InvocationPolicy_UseDefault {
    get {
      if case .useDefault(let v)? = _storage._operation {return v}
      return Blaze_InvocationPolicy_UseDefault()
    }
    set {_uniqueStorage()._operation = .useDefault(newValue)}
  }

  public var disallowValues: Blaze_InvocationPolicy_DisallowValues {
    get {
      if case .disallowValues(let v)? = _storage._operation {return v}
      return Blaze_InvocationPolicy_DisallowValues()
    }
    set {_uniqueStorage()._operation = .disallowValues(newValue)}
  }

  public var allowValues: Blaze_InvocationPolicy_AllowValues {
    get {
      if case .allowValues(let v)? = _storage._operation {return v}
      return Blaze_InvocationPolicy_AllowValues()
    }
    set {_uniqueStorage()._operation = .allowValues(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable {
    case setValue(Blaze_InvocationPolicy_SetValue)
    case useDefault(Blaze_InvocationPolicy_UseDefault)
    case disallowValues(Blaze_InvocationPolicy_DisallowValues)
    case allowValues(Blaze_InvocationPolicy_AllowValues)

  #if !swift(>=4.1)
    public static func ==(lhs: Blaze_InvocationPolicy_FlagPolicy.OneOf_Operation, rhs: Blaze_InvocationPolicy_FlagPolicy.OneOf_Operation) -> Bool {
      switch (lhs, rhs) {
      case (.setValue(let l), .setValue(let r)): return l == r
      case (.useDefault(let l), .useDefault(let r)): return l == r
      case (.disallowValues(let l), .disallowValues(let r)): return l == r
      case (.allowValues(let l), .allowValues(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Blaze_InvocationPolicy_SetValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var flagValue: [String] = []

  public var overridable: Bool {
    get {return _overridable ?? false}
    set {_overridable = newValue}
  }
  /// Returns true if `overridable` has been explicitly set.
  public var hasOverridable: Bool {return self._overridable != nil}
  /// Clears the value of `overridable`. Subsequent reads from it will return its default value.
  public mutating func clearOverridable() {self._overridable = nil}

  public var append: Bool {
    get {return _append ?? false}
    set {_append = newValue}
  }
  /// Returns true if `append` has been explicitly set.
  public var hasAppend: Bool {return self._append != nil}
  /// Clears the value of `append`. Subsequent reads from it will return its default value.
  public mutating func clearAppend() {self._append = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _overridable: Bool? = nil
  fileprivate var _append: Bool? = nil
}

public struct Blaze_InvocationPolicy_UseDefault {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Blaze_InvocationPolicy_DisallowValues {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var disallowedValues: [String] {
    get {return _storage._disallowedValues}
    set {_uniqueStorage()._disallowedValues = newValue}
  }

  public var replacementValue: OneOf_ReplacementValue? {
    get {return _storage._replacementValue}
    set {_uniqueStorage()._replacementValue = newValue}
  }

  public var newValue: String {
    get {
      if case .newValue(let v)? = _storage._replacementValue {return v}
      return String()
    }
    set {_uniqueStorage()._replacementValue = .newValue(newValue)}
  }

  public var useDefault: Blaze_InvocationPolicy_UseDefault {
    get {
      if case .useDefault(let v)? = _storage._replacementValue {return v}
      return Blaze_InvocationPolicy_UseDefault()
    }
    set {_uniqueStorage()._replacementValue = .useDefault(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ReplacementValue: Equatable {
    case newValue(String)
    case useDefault(Blaze_InvocationPolicy_UseDefault)

  #if !swift(>=4.1)
    public static func ==(lhs: Blaze_InvocationPolicy_DisallowValues.OneOf_ReplacementValue, rhs: Blaze_InvocationPolicy_DisallowValues.OneOf_ReplacementValue) -> Bool {
      switch (lhs, rhs) {
      case (.newValue(let l), .newValue(let r)): return l == r
      case (.useDefault(let l), .useDefault(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Blaze_InvocationPolicy_AllowValues {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var allowedValues: [String] {
    get {return _storage._allowedValues}
    set {_uniqueStorage()._allowedValues = newValue}
  }

  public var replacementValue: OneOf_ReplacementValue? {
    get {return _storage._replacementValue}
    set {_uniqueStorage()._replacementValue = newValue}
  }

  public var newValue: String {
    get {
      if case .newValue(let v)? = _storage._replacementValue {return v}
      return String()
    }
    set {_uniqueStorage()._replacementValue = .newValue(newValue)}
  }

  public var useDefault: Blaze_InvocationPolicy_UseDefault {
    get {
      if case .useDefault(let v)? = _storage._replacementValue {return v}
      return Blaze_InvocationPolicy_UseDefault()
    }
    set {_uniqueStorage()._replacementValue = .useDefault(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ReplacementValue: Equatable {
    case newValue(String)
    case useDefault(Blaze_InvocationPolicy_UseDefault)

  #if !swift(>=4.1)
    public static func ==(lhs: Blaze_InvocationPolicy_AllowValues.OneOf_ReplacementValue, rhs: Blaze_InvocationPolicy_AllowValues.OneOf_ReplacementValue) -> Bool {
      switch (lhs, rhs) {
      case (.newValue(let l), .newValue(let r)): return l == r
      case (.useDefault(let l), .useDefault(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "blaze.invocation_policy"

extension Blaze_InvocationPolicy_InvocationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvocationPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flag_policies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.flagPolicies)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flagPolicies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagPolicies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_InvocationPolicy, rhs: Blaze_InvocationPolicy_InvocationPolicy) -> Bool {
    if lhs.flagPolicies != rhs.flagPolicies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_InvocationPolicy_FlagPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlagPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flag_name"),
    2: .same(proto: "commands"),
    3: .standard(proto: "set_value"),
    4: .standard(proto: "use_default"),
    5: .standard(proto: "disallow_values"),
    6: .standard(proto: "allow_values"),
  ]

  fileprivate class _StorageClass {
    var _flagName: String? = nil
    var _commands: [String] = []
    var _operation: Blaze_InvocationPolicy_FlagPolicy.OneOf_Operation?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _flagName = source._flagName
      _commands = source._commands
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._flagName)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._commands)
        case 3:
          var v: Blaze_InvocationPolicy_SetValue?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .setValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .setValue(v)}
        case 4:
          var v: Blaze_InvocationPolicy_UseDefault?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .useDefault(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .useDefault(v)}
        case 5:
          var v: Blaze_InvocationPolicy_DisallowValues?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .disallowValues(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .disallowValues(v)}
        case 6:
          var v: Blaze_InvocationPolicy_AllowValues?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .allowValues(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .allowValues(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._flagName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._commands.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commands, fieldNumber: 2)
      }
      switch _storage._operation {
      case .setValue(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .useDefault(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .disallowValues(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .allowValues(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_FlagPolicy, rhs: Blaze_InvocationPolicy_FlagPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._flagName != rhs_storage._flagName {return false}
        if _storage._commands != rhs_storage._commands {return false}
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_InvocationPolicy_SetValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flag_value"),
    2: .same(proto: "overridable"),
    3: .same(proto: "append"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.flagValue)
      case 2: try decoder.decodeSingularBoolField(value: &self._overridable)
      case 3: try decoder.decodeSingularBoolField(value: &self._append)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flagValue.isEmpty {
      try visitor.visitRepeatedStringField(value: self.flagValue, fieldNumber: 1)
    }
    if let v = self._overridable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }
    if let v = self._append {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_SetValue, rhs: Blaze_InvocationPolicy_SetValue) -> Bool {
    if lhs.flagValue != rhs.flagValue {return false}
    if lhs._overridable != rhs._overridable {return false}
    if lhs._append != rhs._append {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_InvocationPolicy_UseDefault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UseDefault"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_UseDefault, rhs: Blaze_InvocationPolicy_UseDefault) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_InvocationPolicy_DisallowValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisallowValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disallowed_values"),
    3: .standard(proto: "new_value"),
    4: .standard(proto: "use_default"),
  ]

  fileprivate class _StorageClass {
    var _disallowedValues: [String] = []
    var _replacementValue: Blaze_InvocationPolicy_DisallowValues.OneOf_ReplacementValue?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _disallowedValues = source._disallowedValues
      _replacementValue = source._replacementValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._disallowedValues)
        case 3:
          if _storage._replacementValue != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._replacementValue = .newValue(v)}
        case 4:
          var v: Blaze_InvocationPolicy_UseDefault?
          if let current = _storage._replacementValue {
            try decoder.handleConflictingOneOf()
            if case .useDefault(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._replacementValue = .useDefault(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._disallowedValues.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._disallowedValues, fieldNumber: 1)
      }
      switch _storage._replacementValue {
      case .newValue(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .useDefault(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_DisallowValues, rhs: Blaze_InvocationPolicy_DisallowValues) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._disallowedValues != rhs_storage._disallowedValues {return false}
        if _storage._replacementValue != rhs_storage._replacementValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Blaze_InvocationPolicy_AllowValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllowValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_values"),
    3: .standard(proto: "new_value"),
    4: .standard(proto: "use_default"),
  ]

  fileprivate class _StorageClass {
    var _allowedValues: [String] = []
    var _replacementValue: Blaze_InvocationPolicy_AllowValues.OneOf_ReplacementValue?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _allowedValues = source._allowedValues
      _replacementValue = source._replacementValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._allowedValues)
        case 3:
          if _storage._replacementValue != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._replacementValue = .newValue(v)}
        case 4:
          var v: Blaze_InvocationPolicy_UseDefault?
          if let current = _storage._replacementValue {
            try decoder.handleConflictingOneOf()
            if case .useDefault(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._replacementValue = .useDefault(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._allowedValues.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._allowedValues, fieldNumber: 1)
      }
      switch _storage._replacementValue {
      case .newValue(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .useDefault(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Blaze_InvocationPolicy_AllowValues, rhs: Blaze_InvocationPolicy_AllowValues) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._allowedValues != rhs_storage._allowedValues {return false}
        if _storage._replacementValue != rhs_storage._replacementValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
