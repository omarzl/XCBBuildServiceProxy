// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

import src_main_protobuf_command_line_proto
import src_main_protobuf_failure_details_proto
import src_main_protobuf_invocation_policy_proto

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration type characterizing the size of a test, as specified by the
/// test rule.
public enum BuildEventStream_TestSize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case small // = 1
  case medium // = 2
  case large // = 3
  case enormous // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .small
    case 2: self = .medium
    case 3: self = .large
    case 4: self = .enormous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .small: return 1
    case .medium: return 2
    case .large: return 3
    case .enormous: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestSize] = [
    .unknown,
    .small,
    .medium,
    .large,
    .enormous,
  ]
}

#endif  // swift(>=4.2)

public enum BuildEventStream_TestStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noStatus // = 0
  case passed // = 1
  case flaky // = 2
  case timeout // = 3
  case failed // = 4
  case incomplete // = 5
  case remoteFailure // = 6
  case failedToBuild // = 7
  case toolHaltedBeforeTesting // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStatus
    case 1: self = .passed
    case 2: self = .flaky
    case 3: self = .timeout
    case 4: self = .failed
    case 5: self = .incomplete
    case 6: self = .remoteFailure
    case 7: self = .failedToBuild
    case 8: self = .toolHaltedBeforeTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStatus: return 0
    case .passed: return 1
    case .flaky: return 2
    case .timeout: return 3
    case .failed: return 4
    case .incomplete: return 5
    case .remoteFailure: return 6
    case .failedToBuild: return 7
    case .toolHaltedBeforeTesting: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestStatus] = [
    .noStatus,
    .passed,
    .flaky,
    .timeout,
    .failed,
    .incomplete,
    .remoteFailure,
    .failedToBuild,
    .toolHaltedBeforeTesting,
  ]
}

#endif  // swift(>=4.2)

/// Identifier for a build event. It is deliberately structured to also provide
/// information about which build target etc the event is related to.
///
/// Events are chained via the event id as follows: each event has an id and a
/// set of ids of children events such that apart from the initial event each
/// event has an id that is mentioned as child id in an earlier event and a build
/// invocation is complete if and only if all direct and indirect children of the
/// initial event have been posted.
public struct BuildEventStream_BuildEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId.OneOf_ID? = nil

  public var unknown: BuildEventStream_BuildEventId.UnknownBuildEventId {
    get {
      if case .unknown(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnknownBuildEventId()
    }
    set {id = .unknown(newValue)}
  }

  public var progress: BuildEventStream_BuildEventId.ProgressId {
    get {
      if case .progress(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ProgressId()
    }
    set {id = .progress(newValue)}
  }

  public var started: BuildEventStream_BuildEventId.BuildStartedId {
    get {
      if case .started(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildStartedId()
    }
    set {id = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_BuildEventId.UnstructuredCommandLineId {
    get {
      if case .unstructuredCommandLine(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnstructuredCommandLineId()
    }
    set {id = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: BuildEventStream_BuildEventId.StructuredCommandLineId {
    get {
      if case .structuredCommandLine(let v)? = id {return v}
      return BuildEventStream_BuildEventId.StructuredCommandLineId()
    }
    set {id = .structuredCommandLine(newValue)}
  }

  public var workspaceStatus: BuildEventStream_BuildEventId.WorkspaceStatusId {
    get {
      if case .workspaceStatus(let v)? = id {return v}
      return BuildEventStream_BuildEventId.WorkspaceStatusId()
    }
    set {id = .workspaceStatus(newValue)}
  }

  public var optionsParsed: BuildEventStream_BuildEventId.OptionsParsedId {
    get {
      if case .optionsParsed(let v)? = id {return v}
      return BuildEventStream_BuildEventId.OptionsParsedId()
    }
    set {id = .optionsParsed(newValue)}
  }

  public var fetch: BuildEventStream_BuildEventId.FetchId {
    get {
      if case .fetch(let v)? = id {return v}
      return BuildEventStream_BuildEventId.FetchId()
    }
    set {id = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {
      if case .configuration(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConfigurationId()
    }
    set {id = .configuration(newValue)}
  }

  public var targetConfigured: BuildEventStream_BuildEventId.TargetConfiguredId {
    get {
      if case .targetConfigured(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TargetConfiguredId()
    }
    set {id = .targetConfigured(newValue)}
  }

  public var pattern: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .pattern(let v)? = id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {id = .pattern(newValue)}
  }

  public var patternSkipped: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .patternSkipped(let v)? = id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {id = .patternSkipped(newValue)}
  }

  public var namedSet: BuildEventStream_BuildEventId.NamedSetOfFilesId {
    get {
      if case .namedSet(let v)? = id {return v}
      return BuildEventStream_BuildEventId.NamedSetOfFilesId()
    }
    set {id = .namedSet(newValue)}
  }

  public var targetCompleted: BuildEventStream_BuildEventId.TargetCompletedId {
    get {
      if case .targetCompleted(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TargetCompletedId()
    }
    set {id = .targetCompleted(newValue)}
  }

  public var actionCompleted: BuildEventStream_BuildEventId.ActionCompletedId {
    get {
      if case .actionCompleted(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ActionCompletedId()
    }
    set {id = .actionCompleted(newValue)}
  }

  public var unconfiguredLabel: BuildEventStream_BuildEventId.UnconfiguredLabelId {
    get {
      if case .unconfiguredLabel(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnconfiguredLabelId()
    }
    set {id = .unconfiguredLabel(newValue)}
  }

  public var configuredLabel: BuildEventStream_BuildEventId.ConfiguredLabelId {
    get {
      if case .configuredLabel(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConfiguredLabelId()
    }
    set {id = .configuredLabel(newValue)}
  }

  public var testResult: BuildEventStream_BuildEventId.TestResultId {
    get {
      if case .testResult(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TestResultId()
    }
    set {id = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_BuildEventId.TestSummaryId {
    get {
      if case .testSummary(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TestSummaryId()
    }
    set {id = .testSummary(newValue)}
  }

  public var buildFinished: BuildEventStream_BuildEventId.BuildFinishedId {
    get {
      if case .buildFinished(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildFinishedId()
    }
    set {id = .buildFinished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildEventId.BuildToolLogsId {
    get {
      if case .buildToolLogs(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildToolLogsId()
    }
    set {id = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildEventId.BuildMetricsId {
    get {
      if case .buildMetrics(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildMetricsId()
    }
    set {id = .buildMetrics(newValue)}
  }

  public var workspace: BuildEventStream_BuildEventId.WorkspaceConfigId {
    get {
      if case .workspace(let v)? = id {return v}
      return BuildEventStream_BuildEventId.WorkspaceConfigId()
    }
    set {id = .workspace(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildEventId.BuildMetadataId {
    get {
      if case .buildMetadata(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildMetadataId()
    }
    set {id = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId {
    get {
      if case .convenienceSymlinksIdentified(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId()
    }
    set {id = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    case unknown(BuildEventStream_BuildEventId.UnknownBuildEventId)
    case progress(BuildEventStream_BuildEventId.ProgressId)
    case started(BuildEventStream_BuildEventId.BuildStartedId)
    case unstructuredCommandLine(BuildEventStream_BuildEventId.UnstructuredCommandLineId)
    case structuredCommandLine(BuildEventStream_BuildEventId.StructuredCommandLineId)
    case workspaceStatus(BuildEventStream_BuildEventId.WorkspaceStatusId)
    case optionsParsed(BuildEventStream_BuildEventId.OptionsParsedId)
    case fetch(BuildEventStream_BuildEventId.FetchId)
    case configuration(BuildEventStream_BuildEventId.ConfigurationId)
    case targetConfigured(BuildEventStream_BuildEventId.TargetConfiguredId)
    case pattern(BuildEventStream_BuildEventId.PatternExpandedId)
    case patternSkipped(BuildEventStream_BuildEventId.PatternExpandedId)
    case namedSet(BuildEventStream_BuildEventId.NamedSetOfFilesId)
    case targetCompleted(BuildEventStream_BuildEventId.TargetCompletedId)
    case actionCompleted(BuildEventStream_BuildEventId.ActionCompletedId)
    case unconfiguredLabel(BuildEventStream_BuildEventId.UnconfiguredLabelId)
    case configuredLabel(BuildEventStream_BuildEventId.ConfiguredLabelId)
    case testResult(BuildEventStream_BuildEventId.TestResultId)
    case testSummary(BuildEventStream_BuildEventId.TestSummaryId)
    case buildFinished(BuildEventStream_BuildEventId.BuildFinishedId)
    case buildToolLogs(BuildEventStream_BuildEventId.BuildToolLogsId)
    case buildMetrics(BuildEventStream_BuildEventId.BuildMetricsId)
    case workspace(BuildEventStream_BuildEventId.WorkspaceConfigId)
    case buildMetadata(BuildEventStream_BuildEventId.BuildMetadataId)
    case convenienceSymlinksIdentified(BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEventId.OneOf_ID, rhs: BuildEventStream_BuildEventId.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unknown, .unknown): return {
        guard case .unknown(let l) = lhs, case .unknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.progress, .progress): return {
        guard case .progress(let l) = lhs, case .progress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.started, .started): return {
        guard case .started(let l) = lhs, case .started(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unstructuredCommandLine, .unstructuredCommandLine): return {
        guard case .unstructuredCommandLine(let l) = lhs, case .unstructuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structuredCommandLine, .structuredCommandLine): return {
        guard case .structuredCommandLine(let l) = lhs, case .structuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceStatus, .workspaceStatus): return {
        guard case .workspaceStatus(let l) = lhs, case .workspaceStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optionsParsed, .optionsParsed): return {
        guard case .optionsParsed(let l) = lhs, case .optionsParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetch, .fetch): return {
        guard case .fetch(let l) = lhs, case .fetch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuration, .configuration): return {
        guard case .configuration(let l) = lhs, case .configuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetConfigured, .targetConfigured): return {
        guard case .targetConfigured(let l) = lhs, case .targetConfigured(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pattern, .pattern): return {
        guard case .pattern(let l) = lhs, case .pattern(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.patternSkipped, .patternSkipped): return {
        guard case .patternSkipped(let l) = lhs, case .patternSkipped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namedSet, .namedSet): return {
        guard case .namedSet(let l) = lhs, case .namedSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetCompleted, .targetCompleted): return {
        guard case .targetCompleted(let l) = lhs, case .targetCompleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionCompleted, .actionCompleted): return {
        guard case .actionCompleted(let l) = lhs, case .actionCompleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unconfiguredLabel, .unconfiguredLabel): return {
        guard case .unconfiguredLabel(let l) = lhs, case .unconfiguredLabel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuredLabel, .configuredLabel): return {
        guard case .configuredLabel(let l) = lhs, case .configuredLabel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testResult, .testResult): return {
        guard case .testResult(let l) = lhs, case .testResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testSummary, .testSummary): return {
        guard case .testSummary(let l) = lhs, case .testSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildFinished, .buildFinished): return {
        guard case .buildFinished(let l) = lhs, case .buildFinished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildToolLogs, .buildToolLogs): return {
        guard case .buildToolLogs(let l) = lhs, case .buildToolLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetrics, .buildMetrics): return {
        guard case .buildMetrics(let l) = lhs, case .buildMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspace, .workspace): return {
        guard case .workspace(let l) = lhs, case .workspace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetadata, .buildMetadata): return {
        guard case .buildMetadata(let l) = lhs, case .buildMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.convenienceSymlinksIdentified, .convenienceSymlinksIdentified): return {
        guard case .convenienceSymlinksIdentified(let l) = lhs, case .convenienceSymlinksIdentified(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Generic identifier for a build event. This is the default type of
  /// BuildEventId, but should not be used outside testing; nevertheless,
  /// tools should handle build events with this kind of id gracefully.
  public struct UnknownBuildEventId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting progress. Those events are also used to
  /// chain in events that come early.
  public struct ProgressId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique identifier. No assumption should be made about how the ids are
    /// assigned; the only meaningful operation on this field is test for
    /// equality.
    public var opaqueCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the beginning of a build; this will
  /// normally be the first event.
  public struct BuildStartedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event indicating the original commandline received by
  /// the bazel server.
  public struct UnstructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event describing the commandline received by Bazel.
  public struct StructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A title for this command line value, as there may be multiple.
    /// For example, a single invocation may wish to report both the literal and
    /// canonical command lines, and this label would be used to differentiate
    /// between both versions.
    public var commandLineLabel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the workspace status.
  public struct WorkspaceStatusId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event reporting on the options included in the command
  /// line, both explicitly and implicitly.
  public struct OptionsParsedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting that an external resource was fetched
  /// from.
  public struct FetchId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The external resource that was fetched from.
    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target pattern has been expanded
  /// further.
  /// Messages of this shape are also used to describe parts of a pattern that
  /// have been skipped for some reason, if the actual expansion was still
  /// carried out (e.g., if keep_going is set). In this case, the
  /// pattern_skipped choice in the id field is to be made.
  public struct PatternExpandedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pattern: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WorkspaceConfigId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildMetadataId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target has been expanded by
  /// identifying for which configurations it should be build.
  public struct TargetConfiguredId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// If not empty, the id refers to the expansion of the target for a given
    /// aspect.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a named set of files (usually artifacts)
  /// to be referred to in later messages.
  public struct NamedSetOfFilesId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the file set; this is an opaque string valid only for the
    /// particular instance of the event stream.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a configuration.
  public struct ConfigurationId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the configuration; users of the protocol should not make
    /// any assumptions about it having any structure, or equality of the
    /// identifier between different streams.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target was built completely; this
  /// does not include running the test if the target is a test target.
  public struct TargetCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// The configuration for which the target was built.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    /// If not empty, the id refers to the completion of the target for a given
    /// aspect.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting that an action was completed (not all
  /// actions are reported, only the ones that can be considered important;
  /// this includes all failed actions).
  public struct ActionCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var primaryOutput: String = String()

    /// Optional, the label of the owner of the action, for reference.
    public var label: String = String()

    /// Optional, the id of the configuration of the action owner.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting an event associated with an unconfigured
  /// label. Usually, this indicates a failure due to a missing input file. In
  /// any case, it will report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier. The
  /// purpose of those events is to serve as the root cause of a failed target.
  public struct UnconfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting an event associated with a configured
  /// label, usually a visibility error. In any case, an event with such an
  /// id will always report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier.
  public struct ConfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting on an individual test run. The label
  /// identifies the test that is reported about, the remaining fields are
  /// in such a way as to uniquely identify the action within a build. In fact,
  /// attempts for the same test, run, shard triple are counted sequentially,
  /// starting with 1.
  public struct TestResultId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var run: Int32 = 0

    public var shard: Int32 = 0

    public var attempt: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting the summary of a test.
  public struct TestSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of the BuildFinished event, indicating the end of a build.
  public struct BuildFinishedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing additional logs/statistics after
  /// completion of the build.
  public struct BuildToolLogsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing build metrics after completion
  /// of the build.
  public struct BuildMetricsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing convenience symlinks information.
  public struct ConvenienceSymlinksIdentifiedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event summarizing the progress of the build so far. Those
/// events are also used to be parents of events where the more logical parent
/// event cannot be posted yet as the needed information is not yet complete.
public struct BuildEventStream_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next chunk of stdout that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stdout: String = String()

  /// The next chunk of stderr that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stderr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event indicating that an expected event will not come, as
/// the build is aborted prematurely for some reason.
public struct BuildEventStream_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: BuildEventStream_Aborted.AbortReason = .unknown

  /// A human readable description with more details about there reason, where
  /// available and useful.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AbortReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The user requested the build to be aborted (e.g., by hitting Ctl-C).
    case userInterrupted // = 1

    /// The user requested that no analysis be performed.
    case noAnalyze // = 8

    /// The user requested that no build be carried out.
    case noBuild // = 9

    /// The build or target was aborted as a timeout was exceeded.
    case timeOut // = 2

    /// The build or target was aborted as some remote environment (e.g., for
    /// remote execution of actions) was not available in the expected way.
    case remoteEnvironmentFailure // = 3

    /// Failure due to reasons entirely internal to the build tool, i.e. an
    /// unexpected crash due to programmer error.
    case `internal` // = 4

    /// A Failure occurred in the loading phase of a target.
    case loadingFailure // = 5

    /// A Failure occurred in the analysis phase of a target.
    case analysisFailure // = 6

    /// Target build was skipped (e.g. due to incompatible CPU constraints).
    case skipped // = 7

    /// Build incomplete due to an earlier build failure (e.g. --keep_going was
    /// set to false causing the build be ended upon failure).
    case incomplete // = 10

    /// The build tool ran out of memory and crashed. Not yet used. OOMs are
    /// currently reported as INTERNAL.
    /// TODO(b/170643206): Use this reason for OOMs after updating consumers.
    case outOfMemory // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userInterrupted
      case 2: self = .timeOut
      case 3: self = .remoteEnvironmentFailure
      case 4: self = .internal
      case 5: self = .loadingFailure
      case 6: self = .analysisFailure
      case 7: self = .skipped
      case 8: self = .noAnalyze
      case 9: self = .noBuild
      case 10: self = .incomplete
      case 11: self = .outOfMemory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userInterrupted: return 1
      case .timeOut: return 2
      case .remoteEnvironmentFailure: return 3
      case .internal: return 4
      case .loadingFailure: return 5
      case .analysisFailure: return 6
      case .skipped: return 7
      case .noAnalyze: return 8
      case .noBuild: return 9
      case .incomplete: return 10
      case .outOfMemory: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_Aborted.AbortReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_Aborted.AbortReason] = [
    .unknown,
    .userInterrupted,
    .noAnalyze,
    .noBuild,
    .timeOut,
    .remoteEnvironmentFailure,
    .internal,
    .loadingFailure,
    .analysisFailure,
    .skipped,
    .incomplete,
    .outOfMemory,
  ]
}

#endif  // swift(>=4.2)

/// Payload of an event indicating the beginning of a new build. Usually, events
/// of those type start a new build-event stream. The target pattern requested
/// to be build is contained in one of the announced child events; it is an
/// invariant that precisely one of the announced child events has a non-empty
/// target pattern.
public struct BuildEventStream_BuildStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  /// Start of the build in ms since the epoch.
  /// TODO(buchgr): Use google.protobuf.TimeStamp once bazel's protoc supports
  /// it.
  public var startTimeMillis: Int64 = 0

  /// Version of the build tool that is running.
  public var buildToolVersion: String = String()

  /// A human-readable description of all the non-default option settings
  public var optionsDescription: String = String()

  /// The name of the command that the user invoked.
  public var command: String = String()

  /// The working directory from which the build tool was invoked.
  public var workingDirectory: String = String()

  /// The directory of the workspace.
  public var workspaceDirectory: String = String()

  /// The process ID of the Bazel server.
  public var serverPid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration related to the blaze workspace and output tree.
public struct BuildEventStream_WorkspaceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root of the local blaze exec root. All output files live underneath
  /// this at "blaze-out/".
  public var localExecRoot: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the command-line of the invocation as
/// originally received by the server. Note that this is not the command-line
/// given by the user, as the client adds information about the invocation,
/// like name and relevant entries of rc-files and client environment variables.
/// However, it does contain enough information to reproduce the build
/// invocation.
public struct BuildEventStream_UnstructuredCommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting on the parsed options, grouped in various ways.
public struct BuildEventStream_OptionsParsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startupOptions: [String] = []

  public var explicitStartupOptions: [String] = []

  public var cmdLine: [String] = []

  public var explicitCmdLine: [String] = []

  public var invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy {
    get {return _invocationPolicy ?? Blaze_InvocationPolicy_InvocationPolicy()}
    set {_invocationPolicy = newValue}
  }
  /// Returns true if `invocationPolicy` has been explicitly set.
  public var hasInvocationPolicy: Bool {return self._invocationPolicy != nil}
  /// Clears the value of `invocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationPolicy() {self._invocationPolicy = nil}

  public var toolTag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy? = nil
}

/// Payload of an event indicating that an external resource was fetched. This
/// event will only occur in streams where an actual fetch happened, not in ones
/// where a cached copy of the entity to be fetched was used.
public struct BuildEventStream_Fetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the workspace status. Key-value pairs can be
/// provided by specifying the workspace_status_command to an executable that
/// returns one key-value pair per line of output (key and value separated by a
/// space).
public struct BuildEventStream_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [BuildEventStream_WorkspaceStatus.Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event reporting custom key-value metadata associated with the
/// build.
public struct BuildEventStream_BuildMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Custom metadata for the build.
  public var metadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting details of a given configuration.
public struct BuildEventStream_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mnemonic: String = String()

  public var platformName: String = String()

  public var cpu: String = String()

  public var makeVariable: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the expansion of a target pattern.
/// The main information is in the chaining part: the id will contain the
/// target pattern that was expanded and the children id will contain the
/// target or target pattern it was expanded to.
public struct BuildEventStream_PatternExpanded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating that the configurations for a target have
/// been identified. As with pattern expansion the main information is in the
/// chaining part: the id will contain the target that was configured and the
/// children id will contain the configured targets it was configured to.
public struct BuildEventStream_TargetConfigured {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// List of all tags associated with this target (for all possible
  /// configurations).
  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sequence of prefixes to apply to the file name to construct a full path.
  /// In most but not all cases, there will be 3 entries:
  ///  1. A root output directory, eg "bazel-out"
  ///  2. A configuration mnemonic, eg "k8-fastbuild"
  ///  3. An output category, eg "genfiles"
  public var pathPrefix: [String] = []

  /// identifier indicating the nature of the file (e.g., "stdout", "stderr")
  public var name: String = String()

  public var file: BuildEventStream_File.OneOf_File? = nil

  /// A location where the contents of the file can be found. The string is
  /// encoded according to RFC2396.
  public var uri: String {
    get {
      if case .uri(let v)? = file {return v}
      return String()
    }
    set {file = .uri(newValue)}
  }

  /// The contents of the file, if they are guaranteed to be short.
  public var contents: Data {
    get {
      if case .contents(let v)? = file {return v}
      return Data()
    }
    set {file = .contents(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_File: Equatable {
    /// A location where the contents of the file can be found. The string is
    /// encoded according to RFC2396.
    case uri(String)
    /// The contents of the file, if they are guaranteed to be short.
    case contents(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_File.OneOf_File, rhs: BuildEventStream_File.OneOf_File) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contents, .contents): return {
        guard case .contents(let l) = lhs, case .contents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Payload of a message to describe a set of files, usually build artifacts, to
/// be referred to later by their name. In this way, files that occur identically
/// as outputs of several targets have to be named only once.
public struct BuildEventStream_NamedSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Files that belong to this named set of files.
  public var files: [BuildEventStream_File] = []

  /// Other named sets whose members also belong to this set.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of an action. The main purpose
/// of posting those events is to provide details on the root cause for a target
/// failing; however, consumers of the build-event protocol must not assume
/// that only failed actions are posted.
public struct BuildEventStream_ActionExecuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// The mnemonic of the action that was executed
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The exit code of the action, if it is available.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Location where to find the standard output of the action
  /// (e.g., a file path).
  public var stdout: BuildEventStream_File {
    get {return _storage._stdout ?? BuildEventStream_File()}
    set {_uniqueStorage()._stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  public var hasStdout: Bool {return _storage._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  public mutating func clearStdout() {_uniqueStorage()._stdout = nil}

  /// Location where to find the standard error of the action
  /// (e.g., a file path).
  public var stderr: BuildEventStream_File {
    get {return _storage._stderr ?? BuildEventStream_File()}
    set {_uniqueStorage()._stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return _storage._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {_uniqueStorage()._stderr = nil}

  /// Deprecated. This field is now present on ActionCompletedId.
  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  /// Deprecated. This field is now present on ActionCompletedId.
  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  /// Primary output; only provided for successful actions.
  public var primaryOutput: BuildEventStream_File {
    get {return _storage._primaryOutput ?? BuildEventStream_File()}
    set {_uniqueStorage()._primaryOutput = newValue}
  }
  /// Returns true if `primaryOutput` has been explicitly set.
  public var hasPrimaryOutput: Bool {return _storage._primaryOutput != nil}
  /// Clears the value of `primaryOutput`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryOutput() {_uniqueStorage()._primaryOutput = nil}

  /// The command-line of the action, if the action is a command.
  public var commandLine: [String] {
    get {return _storage._commandLine}
    set {_uniqueStorage()._commandLine = newValue}
  }

  /// List of paths to log files
  public var actionMetadataLogs: [BuildEventStream_File] {
    get {return _storage._actionMetadataLogs}
    set {_uniqueStorage()._actionMetadataLogs = newValue}
  }

  /// Only populated if success = false, and sometimes not even then.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Collection of all output files belonging to that output group.
public struct BuildEventStream_OutputGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the output group
  public var name: String = String()

  /// List of file sets that belong to this output group as well.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of a target. The target is
/// specified in the id. If the target failed the root causes are provided as
/// children events.
public struct BuildEventStream_TargetComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  /// Deprecated: use the target_kind field in TargetConfigured instead.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  /// Deprecated: use the test_size field in TargetConfigured instead.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// The output files are arranged by their output group. If an output file
  /// is part of multiple output groups, it appears once in each output
  /// group.
  public var outputGroup: [BuildEventStream_OutputGroup] = []

  /// Temporarily, also report the important outputs directly. This is only to
  /// allow existing clients help transition to the deduplicated representation;
  /// new clients should not use it.
  public var importantOutput: [BuildEventStream_File] = []

  /// Report output artifacts (referenced transitively via output_group) which
  /// emit directories instead of singleton files. These directory_output entries
  /// will never include a uri.
  public var directoryOutput: [BuildEventStream_File] = []

  /// List of tags associated with this configured target.
  public var tag: [String] = []

  /// The timeout specified for test actions under this configured target.
  public var testTimeoutSeconds: Int64 = 0

  /// Failure information about the target, only populated if success is false,
  /// and sometimes not even then. Equal to one of the ActionExecuted
  /// failure_detail fields for one of the root cause ActionExecuted events.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _failureDetail ?? FailureDetails_FailureDetail()}
    set {_failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return self._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {self._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _failureDetail: FailureDetails_FailureDetail? = nil
}

/// Payload on events reporting about individual test action.
public struct BuildEventStream_TestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of this test.
  public var status: BuildEventStream_TestStatus = .noStatus

  /// Additional details about the status of the test. This is intended for
  /// user display and must not be parsed.
  public var statusDetails: String = String()

  /// True, if the reported attempt is taken from the tool's local cache.
  public var cachedLocally: Bool = false

  /// Time in milliseconds since the epoch at which the test attempt was started.
  /// Note: for cached test results, this is time can be before the start of the
  /// build.
  public var testAttemptStartMillisEpoch: Int64 = 0

  /// Time the test took to run. For locally cached results, this is the time
  /// the cached invocation took when it was invoked.
  public var testAttemptDurationMillis: Int64 = 0

  /// Files (logs, test.xml, undeclared outputs, etc) generated by that test
  /// action.
  public var testActionOutput: [BuildEventStream_File] = []

  /// Warnings generated by that test action.
  public var warning: [String] = []

  public var executionInfo: BuildEventStream_TestResult.ExecutionInfo {
    get {return _executionInfo ?? BuildEventStream_TestResult.ExecutionInfo()}
    set {_executionInfo = newValue}
  }
  /// Returns true if `executionInfo` has been explicitly set.
  public var hasExecutionInfo: Bool {return self._executionInfo != nil}
  /// Clears the value of `executionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionInfo() {self._executionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message providing optional meta data on the execution of the test action,
  /// if available.
  public struct ExecutionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated, use TargetComplete.test_timeout_seconds instead.
    public var timeoutSeconds: Int32 = 0

    /// Name of the strategy to execute this test action (e.g., "local",
    /// "remote")
    public var strategy: String = String()

    /// True, if the reported attempt was a cache hit in a remote cache.
    public var cachedRemotely: Bool = false

    /// The exit code of the test action.
    public var exitCode: Int32 = 0

    /// The hostname of the machine where the test action was executed (in case
    /// of remote execution), if known.
    public var hostname: String = String()

    public var timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown {
      get {return _timingBreakdown ?? BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown()}
      set {_timingBreakdown = newValue}
    }
    /// Returns true if `timingBreakdown` has been explicitly set.
    public var hasTimingBreakdown: Bool {return self._timingBreakdown != nil}
    /// Clears the value of `timingBreakdown`. Subsequent reads from it will return its default value.
    public mutating func clearTimingBreakdown() {self._timingBreakdown = nil}

    public var resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents a hierarchical timing breakdown of an activity.
    /// The top level time should be the total time of the activity.
    /// Invariant: time_millis >= sum of time_millis of all direct children.
    public struct TimingBreakdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var child: [BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown] = []

      public var name: String = String()

      public var timeMillis: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct ResourceUsage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown? = nil
  }

  public init() {}

  fileprivate var _executionInfo: BuildEventStream_TestResult.ExecutionInfo? = nil
}

/// Payload of the event summarizing a test.
public struct BuildEventStream_TestSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wrapper around BlazeTestStatus to support importing that enum to proto3.
  /// Overall status of test, accumulated over all runs, shards, and attempts.
  public var overallStatus: BuildEventStream_TestStatus = .noStatus

  /// Total number of runs
  public var totalRunCount: Int32 = 0

  /// Number of runs.
  public var runCount: Int32 = 0

  /// Number of shards.
  public var shardCount: Int32 = 0

  /// Path to logs of passed runs.
  public var passed: [BuildEventStream_File] = []

  /// Path to logs of failed runs;
  public var failed: [BuildEventStream_File] = []

  /// Total number of cached test actions
  public var totalNumCached: Int32 = 0

  /// When the test first started running.
  public var firstStartTimeMillis: Int64 = 0

  /// When the last test action completed.
  public var lastStopTimeMillis: Int64 = 0

  /// The total runtime of the test.
  public var totalRunDurationMillis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event indicating the end of a build.
public struct BuildEventStream_BuildFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the build succeeded or failed.
  public var overallSuccess: Bool = false

  /// The overall status of the build. A build was successful iff
  /// ExitCode.code equals 0.
  public var exitCode: BuildEventStream_BuildFinished.ExitCode {
    get {return _exitCode ?? BuildEventStream_BuildFinished.ExitCode()}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  /// Time in milliseconds since the epoch.
  /// TODO(buchgr): Use google.protobuf.Timestamp once bazel's protoc supports
  /// it.
  public var finishTimeMillis: Int64 = 0

  public var anomalyReport: BuildEventStream_BuildFinished.AnomalyReport {
    get {return _anomalyReport ?? BuildEventStream_BuildFinished.AnomalyReport()}
    set {_anomalyReport = newValue}
  }
  /// Returns true if `anomalyReport` has been explicitly set.
  public var hasAnomalyReport: Bool {return self._anomalyReport != nil}
  /// Clears the value of `anomalyReport`. Subsequent reads from it will return its default value.
  public mutating func clearAnomalyReport() {self._anomalyReport = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exit code of a build. The possible values correspond to the predefined
  /// codes in bazel's lib.ExitCode class, as well as any custom exit code a
  /// module might define. The predefined exit codes are subject to change (but
  /// rarely do) and are not part of the public API.
  ///
  /// A build was successful iff ExitCode.code equals 0.
  public struct ExitCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the exit code.
    public var name: String = String()

    /// The exit code.
    public var code: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Things that happened during the build that could be of interest.
  public struct AnomalyReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Was the build suspended at any time during the build.
    /// Examples of suspensions are SIGSTOP, or the hardware being put to sleep.
    /// If was_suspended is true, then most of the timings for this build are
    /// suspect.
    public var wasSuspended: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _exitCode: BuildEventStream_BuildFinished.ExitCode? = nil
  fileprivate var _anomalyReport: BuildEventStream_BuildFinished.AnomalyReport? = nil
}

public struct BuildEventStream_BuildMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionSummary: BuildEventStream_BuildMetrics.ActionSummary {
    get {return _actionSummary ?? BuildEventStream_BuildMetrics.ActionSummary()}
    set {_actionSummary = newValue}
  }
  /// Returns true if `actionSummary` has been explicitly set.
  public var hasActionSummary: Bool {return self._actionSummary != nil}
  /// Clears the value of `actionSummary`. Subsequent reads from it will return its default value.
  public mutating func clearActionSummary() {self._actionSummary = nil}

  public var memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics {
    get {return _memoryMetrics ?? BuildEventStream_BuildMetrics.MemoryMetrics()}
    set {_memoryMetrics = newValue}
  }
  /// Returns true if `memoryMetrics` has been explicitly set.
  public var hasMemoryMetrics: Bool {return self._memoryMetrics != nil}
  /// Clears the value of `memoryMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearMemoryMetrics() {self._memoryMetrics = nil}

  public var targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics {
    get {return _targetMetrics ?? BuildEventStream_BuildMetrics.TargetMetrics()}
    set {_targetMetrics = newValue}
  }
  /// Returns true if `targetMetrics` has been explicitly set.
  public var hasTargetMetrics: Bool {return self._targetMetrics != nil}
  /// Clears the value of `targetMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTargetMetrics() {self._targetMetrics = nil}

  public var packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics {
    get {return _packageMetrics ?? BuildEventStream_BuildMetrics.PackageMetrics()}
    set {_packageMetrics = newValue}
  }
  /// Returns true if `packageMetrics` has been explicitly set.
  public var hasPackageMetrics: Bool {return self._packageMetrics != nil}
  /// Clears the value of `packageMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearPackageMetrics() {self._packageMetrics = nil}

  public var timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics {
    get {return _timingMetrics ?? BuildEventStream_BuildMetrics.TimingMetrics()}
    set {_timingMetrics = newValue}
  }
  /// Returns true if `timingMetrics` has been explicitly set.
  public var hasTimingMetrics: Bool {return self._timingMetrics != nil}
  /// Clears the value of `timingMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTimingMetrics() {self._timingMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ActionSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total number of actions created and registered during the build.
    /// This includes unused actions that were constructed but
    /// not executed during this build.
    public var actionsCreated: Int64 = 0

    /// The total number of actions executed during the build.
    /// This includes any remote cache hits, but excludes
    /// local action cache hits.
    public var actionsExecuted: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MemoryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Size of the JVM heap post build in bytes. This is only collected if
    /// --bep_publish_used_heap_size_post_build is set,
    /// since it forces a full GC.
    public var usedHeapSizePostBuild: Int64 = 0

    /// Size of the peak JVM heap size in bytes post GC. Note that this reports 0
    /// if there was no major GC during the build.
    public var peakPostGcHeapSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TargetMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of targets loaded during this build.
    public var targetsLoaded: Int64 = 0

    /// Number of targets configured during this build. This can
    /// be greater than targets_loaded if the same target is configured
    /// multiple times.
    public var targetsConfigured: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PackageMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of BUILD files (aka packages) loaded during this build.
    public var packagesLoaded: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TimingMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The CPU time in milliseconds consumed during this build.
    public var cpuTimeInMs: Int64 = 0

    /// The elapsed wall time in milliseconds during this build.
    public var wallTimeInMs: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _actionSummary: BuildEventStream_BuildMetrics.ActionSummary? = nil
  fileprivate var _memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics? = nil
  fileprivate var _targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics? = nil
  fileprivate var _packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics? = nil
  fileprivate var _timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics? = nil
}

/// Event providing additional statistics/logs after completion of the build.
public struct BuildEventStream_BuildToolLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: [BuildEventStream_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event describing all convenience symlinks (i.e., workspace symlinks) to be
/// created or deleted once the execution phase has begun. Note that this event
/// does not say anything about whether or not the build tool actually executed
/// these filesystem operations; it only says what logical operations should be
/// performed. This event is emitted exactly once per build; if no symlinks are
/// to be modified, the event is still emitted with empty contents.
public struct BuildEventStream_ConvenienceSymlinksIdentified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var convenienceSymlinks: [BuildEventStream_ConvenienceSymlink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message that contains what type of action to perform on a given path and
/// target of a symlink.
public struct BuildEventStream_ConvenienceSymlink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of the symlink to be created or deleted, absolute or relative to
  /// the workspace, creating any directories necessary. If a symlink already
  /// exists at that location, then it should be replaced by a symlink pointing
  /// to the new target.
  public var path: String = String()

  /// The operation we are performing on the symlink.
  public var action: BuildEventStream_ConvenienceSymlink.Action = .unknown

  /// If action is CREATE, this is the target path that the symlink should point
  /// to. If the path points underneath the output base, it is relative to the
  /// output base; otherwise it is absolute.
  ///
  /// If action is DELETE, this field is not set.
  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Indicates a symlink should be created, or overwritten if it already
    /// exists.
    case create // = 1

    /// Indicates a symlink should be deleted if it already exists.
    case delete // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .create
      case 2: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .create: return 1
      case .delete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_ConvenienceSymlink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_ConvenienceSymlink.Action] = [
    .unknown,
    .create,
    .delete,
  ]
}

#endif  // swift(>=4.2)

/// Message describing a build event. Events will have an identifier that
/// is unique within a given build invocation; they also announce follow-up
/// events as children. More details, which are specific to the kind of event
/// that is observed, is provided in the payload. More options for the payload
/// might be added in the future.
public struct BuildEventStream_BuildEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId {
    get {return _storage._id ?? BuildEventStream_BuildEventId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var children: [BuildEventStream_BuildEventId] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var lastMessage: Bool {
    get {return _storage._lastMessage}
    set {_uniqueStorage()._lastMessage = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var progress: BuildEventStream_Progress {
    get {
      if case .progress(let v)? = _storage._payload {return v}
      return BuildEventStream_Progress()
    }
    set {_uniqueStorage()._payload = .progress(newValue)}
  }

  public var aborted: BuildEventStream_Aborted {
    get {
      if case .aborted(let v)? = _storage._payload {return v}
      return BuildEventStream_Aborted()
    }
    set {_uniqueStorage()._payload = .aborted(newValue)}
  }

  public var started: BuildEventStream_BuildStarted {
    get {
      if case .started(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildStarted()
    }
    set {_uniqueStorage()._payload = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_UnstructuredCommandLine {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._payload {return v}
      return BuildEventStream_UnstructuredCommandLine()
    }
    set {_uniqueStorage()._payload = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: CommandLine_CommandLine {
    get {
      if case .structuredCommandLine(let v)? = _storage._payload {return v}
      return CommandLine_CommandLine()
    }
    set {_uniqueStorage()._payload = .structuredCommandLine(newValue)}
  }

  public var optionsParsed: BuildEventStream_OptionsParsed {
    get {
      if case .optionsParsed(let v)? = _storage._payload {return v}
      return BuildEventStream_OptionsParsed()
    }
    set {_uniqueStorage()._payload = .optionsParsed(newValue)}
  }

  public var workspaceStatus: BuildEventStream_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceStatus()
    }
    set {_uniqueStorage()._payload = .workspaceStatus(newValue)}
  }

  public var fetch: BuildEventStream_Fetch {
    get {
      if case .fetch(let v)? = _storage._payload {return v}
      return BuildEventStream_Fetch()
    }
    set {_uniqueStorage()._payload = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_Configuration {
    get {
      if case .configuration(let v)? = _storage._payload {return v}
      return BuildEventStream_Configuration()
    }
    set {_uniqueStorage()._payload = .configuration(newValue)}
  }

  public var expanded: BuildEventStream_PatternExpanded {
    get {
      if case .expanded(let v)? = _storage._payload {return v}
      return BuildEventStream_PatternExpanded()
    }
    set {_uniqueStorage()._payload = .expanded(newValue)}
  }

  public var configured: BuildEventStream_TargetConfigured {
    get {
      if case .configured(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetConfigured()
    }
    set {_uniqueStorage()._payload = .configured(newValue)}
  }

  public var action: BuildEventStream_ActionExecuted {
    get {
      if case .action(let v)? = _storage._payload {return v}
      return BuildEventStream_ActionExecuted()
    }
    set {_uniqueStorage()._payload = .action(newValue)}
  }

  public var namedSetOfFiles: BuildEventStream_NamedSetOfFiles {
    get {
      if case .namedSetOfFiles(let v)? = _storage._payload {return v}
      return BuildEventStream_NamedSetOfFiles()
    }
    set {_uniqueStorage()._payload = .namedSetOfFiles(newValue)}
  }

  public var completed: BuildEventStream_TargetComplete {
    get {
      if case .completed(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetComplete()
    }
    set {_uniqueStorage()._payload = .completed(newValue)}
  }

  public var testResult: BuildEventStream_TestResult {
    get {
      if case .testResult(let v)? = _storage._payload {return v}
      return BuildEventStream_TestResult()
    }
    set {_uniqueStorage()._payload = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_TestSummary {
    get {
      if case .testSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TestSummary()
    }
    set {_uniqueStorage()._payload = .testSummary(newValue)}
  }

  public var finished: BuildEventStream_BuildFinished {
    get {
      if case .finished(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildFinished()
    }
    set {_uniqueStorage()._payload = .finished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildToolLogs {
    get {
      if case .buildToolLogs(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildToolLogs()
    }
    set {_uniqueStorage()._payload = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildMetrics {
    get {
      if case .buildMetrics(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetrics()
    }
    set {_uniqueStorage()._payload = .buildMetrics(newValue)}
  }

  public var workspaceInfo: BuildEventStream_WorkspaceConfig {
    get {
      if case .workspaceInfo(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceConfig()
    }
    set {_uniqueStorage()._payload = .workspaceInfo(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildMetadata {
    get {
      if case .buildMetadata(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetadata()
    }
    set {_uniqueStorage()._payload = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_ConvenienceSymlinksIdentified {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._payload {return v}
      return BuildEventStream_ConvenienceSymlinksIdentified()
    }
    set {_uniqueStorage()._payload = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case progress(BuildEventStream_Progress)
    case aborted(BuildEventStream_Aborted)
    case started(BuildEventStream_BuildStarted)
    case unstructuredCommandLine(BuildEventStream_UnstructuredCommandLine)
    case structuredCommandLine(CommandLine_CommandLine)
    case optionsParsed(BuildEventStream_OptionsParsed)
    case workspaceStatus(BuildEventStream_WorkspaceStatus)
    case fetch(BuildEventStream_Fetch)
    case configuration(BuildEventStream_Configuration)
    case expanded(BuildEventStream_PatternExpanded)
    case configured(BuildEventStream_TargetConfigured)
    case action(BuildEventStream_ActionExecuted)
    case namedSetOfFiles(BuildEventStream_NamedSetOfFiles)
    case completed(BuildEventStream_TargetComplete)
    case testResult(BuildEventStream_TestResult)
    case testSummary(BuildEventStream_TestSummary)
    case finished(BuildEventStream_BuildFinished)
    case buildToolLogs(BuildEventStream_BuildToolLogs)
    case buildMetrics(BuildEventStream_BuildMetrics)
    case workspaceInfo(BuildEventStream_WorkspaceConfig)
    case buildMetadata(BuildEventStream_BuildMetadata)
    case convenienceSymlinksIdentified(BuildEventStream_ConvenienceSymlinksIdentified)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEvent.OneOf_Payload, rhs: BuildEventStream_BuildEvent.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.progress, .progress): return {
        guard case .progress(let l) = lhs, case .progress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aborted, .aborted): return {
        guard case .aborted(let l) = lhs, case .aborted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.started, .started): return {
        guard case .started(let l) = lhs, case .started(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unstructuredCommandLine, .unstructuredCommandLine): return {
        guard case .unstructuredCommandLine(let l) = lhs, case .unstructuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structuredCommandLine, .structuredCommandLine): return {
        guard case .structuredCommandLine(let l) = lhs, case .structuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optionsParsed, .optionsParsed): return {
        guard case .optionsParsed(let l) = lhs, case .optionsParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceStatus, .workspaceStatus): return {
        guard case .workspaceStatus(let l) = lhs, case .workspaceStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetch, .fetch): return {
        guard case .fetch(let l) = lhs, case .fetch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuration, .configuration): return {
        guard case .configuration(let l) = lhs, case .configuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expanded, .expanded): return {
        guard case .expanded(let l) = lhs, case .expanded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configured, .configured): return {
        guard case .configured(let l) = lhs, case .configured(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namedSetOfFiles, .namedSetOfFiles): return {
        guard case .namedSetOfFiles(let l) = lhs, case .namedSetOfFiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.completed, .completed): return {
        guard case .completed(let l) = lhs, case .completed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testResult, .testResult): return {
        guard case .testResult(let l) = lhs, case .testResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testSummary, .testSummary): return {
        guard case .testSummary(let l) = lhs, case .testSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finished, .finished): return {
        guard case .finished(let l) = lhs, case .finished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildToolLogs, .buildToolLogs): return {
        guard case .buildToolLogs(let l) = lhs, case .buildToolLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetrics, .buildMetrics): return {
        guard case .buildMetrics(let l) = lhs, case .buildMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceInfo, .workspaceInfo): return {
        guard case .workspaceInfo(let l) = lhs, case .workspaceInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetadata, .buildMetadata): return {
        guard case .buildMetadata(let l) = lhs, case .buildMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.convenienceSymlinksIdentified, .convenienceSymlinksIdentified): return {
        guard case .convenienceSymlinksIdentified(let l) = lhs, case .convenienceSymlinksIdentified(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build_event_stream"

extension BuildEventStream_TestSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
    4: .same(proto: "ENORMOUS"),
  ]
}

extension BuildEventStream_TestStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STATUS"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FLAKY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "REMOTE_FAILURE"),
    7: .same(proto: "FAILED_TO_BUILD"),
    8: .same(proto: "TOOL_HALTED_BEFORE_TESTING"),
  ]
}

extension BuildEventStream_BuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "progress"),
    3: .same(proto: "started"),
    11: .standard(proto: "unstructured_command_line"),
    18: .standard(proto: "structured_command_line"),
    14: .standard(proto: "workspace_status"),
    12: .standard(proto: "options_parsed"),
    17: .same(proto: "fetch"),
    15: .same(proto: "configuration"),
    16: .standard(proto: "target_configured"),
    4: .same(proto: "pattern"),
    10: .standard(proto: "pattern_skipped"),
    13: .standard(proto: "named_set"),
    5: .standard(proto: "target_completed"),
    6: .standard(proto: "action_completed"),
    19: .standard(proto: "unconfigured_label"),
    21: .standard(proto: "configured_label"),
    8: .standard(proto: "test_result"),
    7: .standard(proto: "test_summary"),
    9: .standard(proto: "build_finished"),
    20: .standard(proto: "build_tool_logs"),
    22: .standard(proto: "build_metrics"),
    23: .same(proto: "workspace"),
    24: .standard(proto: "build_metadata"),
    25: .standard(proto: "convenience_symlinks_identified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BuildEventStream_BuildEventId.UnknownBuildEventId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unknown(v)
        }
      }()
      case 2: try {
        var v: BuildEventStream_BuildEventId.ProgressId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .progress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .progress(v)
        }
      }()
      case 3: try {
        var v: BuildEventStream_BuildEventId.BuildStartedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .started(v)
        }
      }()
      case 4: try {
        var v: BuildEventStream_BuildEventId.PatternExpandedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .pattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .pattern(v)
        }
      }()
      case 5: try {
        var v: BuildEventStream_BuildEventId.TargetCompletedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .targetCompleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .targetCompleted(v)
        }
      }()
      case 6: try {
        var v: BuildEventStream_BuildEventId.ActionCompletedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .actionCompleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .actionCompleted(v)
        }
      }()
      case 7: try {
        var v: BuildEventStream_BuildEventId.TestSummaryId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .testSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .testSummary(v)
        }
      }()
      case 8: try {
        var v: BuildEventStream_BuildEventId.TestResultId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .testResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .testResult(v)
        }
      }()
      case 9: try {
        var v: BuildEventStream_BuildEventId.BuildFinishedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildFinished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildFinished(v)
        }
      }()
      case 10: try {
        var v: BuildEventStream_BuildEventId.PatternExpandedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .patternSkipped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .patternSkipped(v)
        }
      }()
      case 11: try {
        var v: BuildEventStream_BuildEventId.UnstructuredCommandLineId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unstructuredCommandLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unstructuredCommandLine(v)
        }
      }()
      case 12: try {
        var v: BuildEventStream_BuildEventId.OptionsParsedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .optionsParsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .optionsParsed(v)
        }
      }()
      case 13: try {
        var v: BuildEventStream_BuildEventId.NamedSetOfFilesId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .namedSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .namedSet(v)
        }
      }()
      case 14: try {
        var v: BuildEventStream_BuildEventId.WorkspaceStatusId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .workspaceStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .workspaceStatus(v)
        }
      }()
      case 15: try {
        var v: BuildEventStream_BuildEventId.ConfigurationId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .configuration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .configuration(v)
        }
      }()
      case 16: try {
        var v: BuildEventStream_BuildEventId.TargetConfiguredId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .targetConfigured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .targetConfigured(v)
        }
      }()
      case 17: try {
        var v: BuildEventStream_BuildEventId.FetchId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .fetch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .fetch(v)
        }
      }()
      case 18: try {
        var v: BuildEventStream_BuildEventId.StructuredCommandLineId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .structuredCommandLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .structuredCommandLine(v)
        }
      }()
      case 19: try {
        var v: BuildEventStream_BuildEventId.UnconfiguredLabelId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unconfiguredLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unconfiguredLabel(v)
        }
      }()
      case 20: try {
        var v: BuildEventStream_BuildEventId.BuildToolLogsId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildToolLogs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildToolLogs(v)
        }
      }()
      case 21: try {
        var v: BuildEventStream_BuildEventId.ConfiguredLabelId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .configuredLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .configuredLabel(v)
        }
      }()
      case 22: try {
        var v: BuildEventStream_BuildEventId.BuildMetricsId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildMetrics(v)
        }
      }()
      case 23: try {
        var v: BuildEventStream_BuildEventId.WorkspaceConfigId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .workspace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .workspace(v)
        }
      }()
      case 24: try {
        var v: BuildEventStream_BuildEventId.BuildMetadataId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildMetadata(v)
        }
      }()
      case 25: try {
        var v: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .convenienceSymlinksIdentified(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .convenienceSymlinksIdentified(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .unknown?: try {
      guard case .unknown(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .progress?: try {
      guard case .progress(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .started?: try {
      guard case .started(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .pattern?: try {
      guard case .pattern(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .targetCompleted?: try {
      guard case .targetCompleted(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .actionCompleted?: try {
      guard case .actionCompleted(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .testSummary?: try {
      guard case .testSummary(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .testResult?: try {
      guard case .testResult(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .buildFinished?: try {
      guard case .buildFinished(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .patternSkipped?: try {
      guard case .patternSkipped(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .unstructuredCommandLine?: try {
      guard case .unstructuredCommandLine(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .optionsParsed?: try {
      guard case .optionsParsed(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .namedSet?: try {
      guard case .namedSet(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .workspaceStatus?: try {
      guard case .workspaceStatus(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .configuration?: try {
      guard case .configuration(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .targetConfigured?: try {
      guard case .targetConfigured(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .fetch?: try {
      guard case .fetch(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .structuredCommandLine?: try {
      guard case .structuredCommandLine(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .unconfiguredLabel?: try {
      guard case .unconfiguredLabel(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .buildToolLogs?: try {
      guard case .buildToolLogs(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .configuredLabel?: try {
      guard case .configuredLabel(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .buildMetrics?: try {
      guard case .buildMetrics(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .workspace?: try {
      guard case .workspace(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .buildMetadata?: try {
      guard case .buildMetadata(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .convenienceSymlinksIdentified?: try {
      guard case .convenienceSymlinksIdentified(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId, rhs: BuildEventStream_BuildEventId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnknownBuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnknownBuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnknownBuildEventId, rhs: BuildEventStream_BuildEventId.UnknownBuildEventId) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ProgressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ProgressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opaque_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.opaqueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.opaqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.opaqueCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ProgressId, rhs: BuildEventStream_BuildEventId.ProgressId) -> Bool {
    if lhs.opaqueCount != rhs.opaqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildStartedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildStartedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildStartedId, rhs: BuildEventStream_BuildEventId.BuildStartedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnstructuredCommandLineId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId, rhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.StructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".StructuredCommandLineId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commandLineLabel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLineLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLineLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.StructuredCommandLineId, rhs: BuildEventStream_BuildEventId.StructuredCommandLineId) -> Bool {
    if lhs.commandLineLabel != rhs.commandLineLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceStatusId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceStatusId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceStatusId, rhs: BuildEventStream_BuildEventId.WorkspaceStatusId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.OptionsParsedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".OptionsParsedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.OptionsParsedId, rhs: BuildEventStream_BuildEventId.OptionsParsedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.FetchId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".FetchId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.FetchId, rhs: BuildEventStream_BuildEventId.FetchId) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.PatternExpandedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".PatternExpandedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pattern) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.PatternExpandedId, rhs: BuildEventStream_BuildEventId.PatternExpandedId) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceConfigId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceConfigId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceConfigId, rhs: BuildEventStream_BuildEventId.WorkspaceConfigId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetadataId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetadataId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetadataId, rhs: BuildEventStream_BuildEventId.BuildMetadataId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetConfiguredId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetConfiguredId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aspect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetConfiguredId, rhs: BuildEventStream_BuildEventId.TargetConfiguredId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.NamedSetOfFilesId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".NamedSetOfFilesId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.NamedSetOfFilesId, rhs: BuildEventStream_BuildEventId.NamedSetOfFilesId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfigurationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfigurationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfigurationId, rhs: BuildEventStream_BuildEventId.ConfigurationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    3: .same(proto: "configuration"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aspect) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetCompletedId, rhs: BuildEventStream_BuildEventId.TargetCompletedId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ActionCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ActionCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_output"),
    2: .same(proto: "label"),
    3: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.primaryOutput) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.primaryOutput.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryOutput, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ActionCompletedId, rhs: BuildEventStream_BuildEventId.ActionCompletedId) -> Bool {
    if lhs.primaryOutput != rhs.primaryOutput {return false}
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnconfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnconfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnconfiguredLabelId, rhs: BuildEventStream_BuildEventId.UnconfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfiguredLabelId, rhs: BuildEventStream_BuildEventId.ConfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestResultId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestResultId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    5: .same(proto: "configuration"),
    2: .same(proto: "run"),
    3: .same(proto: "shard"),
    4: .same(proto: "attempt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.run) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.shard) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.run != 0 {
      try visitor.visitSingularInt32Field(value: self.run, fieldNumber: 2)
    }
    if self.shard != 0 {
      try visitor.visitSingularInt32Field(value: self.shard, fieldNumber: 3)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 4)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestResultId, rhs: BuildEventStream_BuildEventId.TestResultId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.run != rhs.run {return false}
    if lhs.shard != rhs.shard {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestSummaryId, rhs: BuildEventStream_BuildEventId.TestSummaryId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildFinishedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildFinishedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildFinishedId, rhs: BuildEventStream_BuildEventId.BuildFinishedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildToolLogsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildToolLogsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildToolLogsId, rhs: BuildEventStream_BuildEventId.BuildToolLogsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetricsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetricsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetricsId, rhs: BuildEventStream_BuildEventId.BuildMetricsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConvenienceSymlinksIdentifiedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId, rhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stdout) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stderr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularStringField(value: self.stderr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Progress, rhs: BuildEventStream_Progress) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aborted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Aborted, rhs: BuildEventStream_Aborted) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted.AbortReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER_INTERRUPTED"),
    2: .same(proto: "TIME_OUT"),
    3: .same(proto: "REMOTE_ENVIRONMENT_FAILURE"),
    4: .same(proto: "INTERNAL"),
    5: .same(proto: "LOADING_FAILURE"),
    6: .same(proto: "ANALYSIS_FAILURE"),
    7: .same(proto: "SKIPPED"),
    8: .same(proto: "NO_ANALYZE"),
    9: .same(proto: "NO_BUILD"),
    10: .same(proto: "INCOMPLETE"),
    11: .same(proto: "OUT_OF_MEMORY"),
  ]
}

extension BuildEventStream_BuildStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStarted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "start_time_millis"),
    3: .standard(proto: "build_tool_version"),
    4: .standard(proto: "options_description"),
    5: .same(proto: "command"),
    6: .standard(proto: "working_directory"),
    7: .standard(proto: "workspace_directory"),
    8: .standard(proto: "server_pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTimeMillis) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buildToolVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.optionsDescription) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.workingDirectory) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.workspaceDirectory) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.serverPid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.startTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMillis, fieldNumber: 2)
    }
    if !self.buildToolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.buildToolVersion, fieldNumber: 3)
    }
    if !self.optionsDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionsDescription, fieldNumber: 4)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.workspaceDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDirectory, fieldNumber: 7)
    }
    if self.serverPid != 0 {
      try visitor.visitSingularInt64Field(value: self.serverPid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildStarted, rhs: BuildEventStream_BuildStarted) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.startTimeMillis != rhs.startTimeMillis {return false}
    if lhs.buildToolVersion != rhs.buildToolVersion {return false}
    if lhs.optionsDescription != rhs.optionsDescription {return false}
    if lhs.command != rhs.command {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.workspaceDirectory != rhs.workspaceDirectory {return false}
    if lhs.serverPid != rhs.serverPid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_exec_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localExecRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localExecRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.localExecRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceConfig, rhs: BuildEventStream_WorkspaceConfig) -> Bool {
    if lhs.localExecRoot != rhs.localExecRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_UnstructuredCommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnstructuredCommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_UnstructuredCommandLine, rhs: BuildEventStream_UnstructuredCommandLine) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OptionsParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionsParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "startup_options"),
    2: .standard(proto: "explicit_startup_options"),
    3: .standard(proto: "cmd_line"),
    4: .standard(proto: "explicit_cmd_line"),
    5: .standard(proto: "invocation_policy"),
    6: .standard(proto: "tool_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.startupOptions) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.explicitStartupOptions) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.cmdLine) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.explicitCmdLine) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._invocationPolicy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.toolTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.startupOptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.startupOptions, fieldNumber: 1)
    }
    if !self.explicitStartupOptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.explicitStartupOptions, fieldNumber: 2)
    }
    if !self.cmdLine.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cmdLine, fieldNumber: 3)
    }
    if !self.explicitCmdLine.isEmpty {
      try visitor.visitRepeatedStringField(value: self.explicitCmdLine, fieldNumber: 4)
    }
    try { if let v = self._invocationPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.toolTag.isEmpty {
      try visitor.visitSingularStringField(value: self.toolTag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OptionsParsed, rhs: BuildEventStream_OptionsParsed) -> Bool {
    if lhs.startupOptions != rhs.startupOptions {return false}
    if lhs.explicitStartupOptions != rhs.explicitStartupOptions {return false}
    if lhs.cmdLine != rhs.cmdLine {return false}
    if lhs.explicitCmdLine != rhs.explicitCmdLine {return false}
    if lhs._invocationPolicy != rhs._invocationPolicy {return false}
    if lhs.toolTag != rhs.toolTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fetch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Fetch, rhs: BuildEventStream_Fetch) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus, rhs: BuildEventStream_WorkspaceStatus) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_WorkspaceStatus.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus.Item, rhs: BuildEventStream_WorkspaceStatus.Item) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetadata, rhs: BuildEventStream_BuildMetadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "platform_name"),
    3: .same(proto: "cpu"),
    4: .standard(proto: "make_variable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.platformName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cpu) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.makeVariable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 2)
    }
    if !self.cpu.isEmpty {
      try visitor.visitSingularStringField(value: self.cpu, fieldNumber: 3)
    }
    if !self.makeVariable.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.makeVariable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Configuration, rhs: BuildEventStream_Configuration) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.cpu != rhs.cpu {return false}
    if lhs.makeVariable != rhs.makeVariable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternExpanded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded, rhs: BuildEventStream_PatternExpanded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetConfigured"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_kind"),
    2: .standard(proto: "test_size"),
    3: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetKind) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.testSize) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 1)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetConfigured, rhs: BuildEventStream_TargetConfigured) -> Bool {
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "path_prefix"),
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.file != nil {try decoder.handleConflictingOneOf()}
          self.file = .uri(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.file != nil {try decoder.handleConflictingOneOf()}
          self.file = .contents(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.pathPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.file {
    case .uri?: try {
      guard case .uri(let v)? = self.file else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .contents?: try {
      guard case .contents(let v)? = self.file else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.pathPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathPrefix, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_File, rhs: BuildEventStream_File) -> Bool {
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_NamedSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_NamedSetOfFiles, rhs: BuildEventStream_NamedSetOfFiles) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ActionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionExecuted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    8: .same(proto: "type"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "stdout"),
    4: .same(proto: "stderr"),
    5: .same(proto: "label"),
    7: .same(proto: "configuration"),
    6: .standard(proto: "primary_output"),
    9: .standard(proto: "command_line"),
    10: .standard(proto: "action_metadata_logs"),
    11: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _type: String = String()
    var _exitCode: Int32 = 0
    var _stdout: BuildEventStream_File? = nil
    var _stderr: BuildEventStream_File? = nil
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _primaryOutput: BuildEventStream_File? = nil
    var _commandLine: [String] = []
    var _actionMetadataLogs: [BuildEventStream_File] = []
    var _failureDetail: FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _type = source._type
      _exitCode = source._exitCode
      _stdout = source._stdout
      _stderr = source._stderr
      _label = source._label
      _configuration = source._configuration
      _primaryOutput = source._primaryOutput
      _commandLine = source._commandLine
      _actionMetadataLogs = source._actionMetadataLogs
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._exitCode) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stdout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stderr) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._label) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._primaryOutput) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._configuration) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._commandLine) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._actionMetadataLogs) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._failureDetail) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 2)
      }
      try { if let v = _storage._stdout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stderr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      try { if let v = _storage._primaryOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._commandLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandLine, fieldNumber: 9)
      }
      if !_storage._actionMetadataLogs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionMetadataLogs, fieldNumber: 10)
      }
      try { if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ActionExecuted, rhs: BuildEventStream_ActionExecuted) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._stdout != rhs_storage._stdout {return false}
        if _storage._stderr != rhs_storage._stderr {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._commandLine != rhs_storage._commandLine {return false}
        if _storage._actionMetadataLogs != rhs_storage._actionMetadataLogs {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OutputGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OutputGroup, rhs: BuildEventStream_OutputGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    5: .standard(proto: "target_kind"),
    6: .standard(proto: "test_size"),
    2: .standard(proto: "output_group"),
    4: .standard(proto: "important_output"),
    8: .standard(proto: "directory_output"),
    3: .same(proto: "tag"),
    7: .standard(proto: "test_timeout_seconds"),
    9: .standard(proto: "failure_detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputGroup) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tag) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.importantOutput) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetKind) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.testSize) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.testTimeoutSeconds) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.directoryOutput) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._failureDetail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.outputGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputGroup, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    if !self.importantOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importantOutput, fieldNumber: 4)
    }
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 5)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 6)
    }
    if self.testTimeoutSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.testTimeoutSeconds, fieldNumber: 7)
    }
    if !self.directoryOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directoryOutput, fieldNumber: 8)
    }
    try { if let v = self._failureDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetComplete, rhs: BuildEventStream_TargetComplete) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.outputGroup != rhs.outputGroup {return false}
    if lhs.importantOutput != rhs.importantOutput {return false}
    if lhs.directoryOutput != rhs.directoryOutput {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.testTimeoutSeconds != rhs.testTimeoutSeconds {return false}
    if lhs._failureDetail != rhs._failureDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "status"),
    9: .standard(proto: "status_details"),
    4: .standard(proto: "cached_locally"),
    6: .standard(proto: "test_attempt_start_millis_epoch"),
    3: .standard(proto: "test_attempt_duration_millis"),
    2: .standard(proto: "test_action_output"),
    7: .same(proto: "warning"),
    8: .standard(proto: "execution_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.testActionOutput) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.testAttemptDurationMillis) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.cachedLocally) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.testAttemptStartMillisEpoch) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.warning) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._executionInfo) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.statusDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.testActionOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testActionOutput, fieldNumber: 2)
    }
    if self.testAttemptDurationMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.testAttemptDurationMillis, fieldNumber: 3)
    }
    if self.cachedLocally != false {
      try visitor.visitSingularBoolField(value: self.cachedLocally, fieldNumber: 4)
    }
    if self.status != .noStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.testAttemptStartMillisEpoch != 0 {
      try visitor.visitSingularInt64Field(value: self.testAttemptStartMillisEpoch, fieldNumber: 6)
    }
    if !self.warning.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warning, fieldNumber: 7)
    }
    try { if let v = self._executionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.statusDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.statusDetails, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult, rhs: BuildEventStream_TestResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.statusDetails != rhs.statusDetails {return false}
    if lhs.cachedLocally != rhs.cachedLocally {return false}
    if lhs.testAttemptStartMillisEpoch != rhs.testAttemptStartMillisEpoch {return false}
    if lhs.testAttemptDurationMillis != rhs.testAttemptDurationMillis {return false}
    if lhs.testActionOutput != rhs.testActionOutput {return false}
    if lhs.warning != rhs.warning {return false}
    if lhs._executionInfo != rhs._executionInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.protoMessageName + ".ExecutionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_seconds"),
    2: .same(proto: "strategy"),
    6: .standard(proto: "cached_remotely"),
    7: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "timing_breakdown"),
    5: .standard(proto: "resource_usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSeconds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.strategy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timingBreakdown) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.resourceUsage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.cachedRemotely) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeoutSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSeconds, fieldNumber: 1)
    }
    if !self.strategy.isEmpty {
      try visitor.visitSingularStringField(value: self.strategy, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    try { if let v = self._timingBreakdown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.resourceUsage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceUsage, fieldNumber: 5)
    }
    if self.cachedRemotely != false {
      try visitor.visitSingularBoolField(value: self.cachedRemotely, fieldNumber: 6)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo, rhs: BuildEventStream_TestResult.ExecutionInfo) -> Bool {
    if lhs.timeoutSeconds != rhs.timeoutSeconds {return false}
    if lhs.strategy != rhs.strategy {return false}
    if lhs.cachedRemotely != rhs.cachedRemotely {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs._timingBreakdown != rhs._timingBreakdown {return false}
    if lhs.resourceUsage != rhs.resourceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".TimingBreakdown"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "name"),
    3: .standard(proto: "time_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.child) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeMillis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.timeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.timeMillis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown, rhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.name != rhs.name {return false}
    if lhs.timeMillis != rhs.timeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage, rhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "overall_status"),
    1: .standard(proto: "total_run_count"),
    10: .standard(proto: "run_count"),
    11: .standard(proto: "shard_count"),
    3: .same(proto: "passed"),
    4: .same(proto: "failed"),
    6: .standard(proto: "total_num_cached"),
    7: .standard(proto: "first_start_time_millis"),
    8: .standard(proto: "last_stop_time_millis"),
    9: .standard(proto: "total_run_duration_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.totalRunCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.passed) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.failed) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.overallStatus) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalNumCached) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.firstStartTimeMillis) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.lastStopTimeMillis) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.totalRunDurationMillis) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.runCount) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.shardCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalRunCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRunCount, fieldNumber: 1)
    }
    if !self.passed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passed, fieldNumber: 3)
    }
    if !self.failed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failed, fieldNumber: 4)
    }
    if self.overallStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallStatus, fieldNumber: 5)
    }
    if self.totalNumCached != 0 {
      try visitor.visitSingularInt32Field(value: self.totalNumCached, fieldNumber: 6)
    }
    if self.firstStartTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.firstStartTimeMillis, fieldNumber: 7)
    }
    if self.lastStopTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.lastStopTimeMillis, fieldNumber: 8)
    }
    if self.totalRunDurationMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.totalRunDurationMillis, fieldNumber: 9)
    }
    if self.runCount != 0 {
      try visitor.visitSingularInt32Field(value: self.runCount, fieldNumber: 10)
    }
    if self.shardCount != 0 {
      try visitor.visitSingularInt32Field(value: self.shardCount, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestSummary, rhs: BuildEventStream_TestSummary) -> Bool {
    if lhs.overallStatus != rhs.overallStatus {return false}
    if lhs.totalRunCount != rhs.totalRunCount {return false}
    if lhs.runCount != rhs.runCount {return false}
    if lhs.shardCount != rhs.shardCount {return false}
    if lhs.passed != rhs.passed {return false}
    if lhs.failed != rhs.failed {return false}
    if lhs.totalNumCached != rhs.totalNumCached {return false}
    if lhs.firstStartTimeMillis != rhs.firstStartTimeMillis {return false}
    if lhs.lastStopTimeMillis != rhs.lastStopTimeMillis {return false}
    if lhs.totalRunDurationMillis != rhs.totalRunDurationMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_success"),
    3: .standard(proto: "exit_code"),
    2: .standard(proto: "finish_time_millis"),
    4: .standard(proto: "anomaly_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.overallSuccess) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.finishTimeMillis) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._exitCode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._anomalyReport) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.overallSuccess != false {
      try visitor.visitSingularBoolField(value: self.overallSuccess, fieldNumber: 1)
    }
    if self.finishTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.finishTimeMillis, fieldNumber: 2)
    }
    try { if let v = self._exitCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._anomalyReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished, rhs: BuildEventStream_BuildFinished) -> Bool {
    if lhs.overallSuccess != rhs.overallSuccess {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs.finishTimeMillis != rhs.finishTimeMillis {return false}
    if lhs._anomalyReport != rhs._anomalyReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.ExitCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".ExitCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.ExitCode, rhs: BuildEventStream_BuildFinished.ExitCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.AnomalyReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".AnomalyReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "was_suspended"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wasSuspended) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wasSuspended != false {
      try visitor.visitSingularBoolField(value: self.wasSuspended, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.AnomalyReport, rhs: BuildEventStream_BuildFinished.AnomalyReport) -> Bool {
    if lhs.wasSuspended != rhs.wasSuspended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_summary"),
    2: .standard(proto: "memory_metrics"),
    3: .standard(proto: "target_metrics"),
    4: .standard(proto: "package_metrics"),
    5: .standard(proto: "timing_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._actionSummary) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memoryMetrics) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._targetMetrics) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._packageMetrics) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timingMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._memoryMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._targetMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._packageMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timingMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics, rhs: BuildEventStream_BuildMetrics) -> Bool {
    if lhs._actionSummary != rhs._actionSummary {return false}
    if lhs._memoryMetrics != rhs._memoryMetrics {return false}
    if lhs._targetMetrics != rhs._targetMetrics {return false}
    if lhs._packageMetrics != rhs._packageMetrics {return false}
    if lhs._timingMetrics != rhs._timingMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actions_created"),
    2: .standard(proto: "actions_executed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.actionsCreated) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.actionsExecuted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsCreated != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreated, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary, rhs: BuildEventStream_BuildMetrics.ActionSummary) -> Bool {
    if lhs.actionsCreated != rhs.actionsCreated {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".MemoryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_heap_size_post_build"),
    2: .standard(proto: "peak_post_gc_heap_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.usedHeapSizePostBuild) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peakPostGcHeapSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedHeapSizePostBuild != 0 {
      try visitor.visitSingularInt64Field(value: self.usedHeapSizePostBuild, fieldNumber: 1)
    }
    if self.peakPostGcHeapSize != 0 {
      try visitor.visitSingularInt64Field(value: self.peakPostGcHeapSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics) -> Bool {
    if lhs.usedHeapSizePostBuild != rhs.usedHeapSizePostBuild {return false}
    if lhs.peakPostGcHeapSize != rhs.peakPostGcHeapSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TargetMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TargetMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "targets_loaded"),
    2: .standard(proto: "targets_configured"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.targetsLoaded) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.targetsConfigured) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetsLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsLoaded, fieldNumber: 1)
    }
    if self.targetsConfigured != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfigured, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TargetMetrics, rhs: BuildEventStream_BuildMetrics.TargetMetrics) -> Bool {
    if lhs.targetsLoaded != rhs.targetsLoaded {return false}
    if lhs.targetsConfigured != rhs.targetsConfigured {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.PackageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".PackageMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packages_loaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.packagesLoaded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packagesLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.packagesLoaded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.PackageMetrics, rhs: BuildEventStream_BuildMetrics.PackageMetrics) -> Bool {
    if lhs.packagesLoaded != rhs.packagesLoaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TimingMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TimingMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_time_in_ms"),
    2: .standard(proto: "wall_time_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.cpuTimeInMs) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.wallTimeInMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuTimeInMs, fieldNumber: 1)
    }
    if self.wallTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.wallTimeInMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TimingMetrics, rhs: BuildEventStream_BuildMetrics.TimingMetrics) -> Bool {
    if lhs.cpuTimeInMs != rhs.cpuTimeInMs {return false}
    if lhs.wallTimeInMs != rhs.wallTimeInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildToolLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildToolLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.log) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildToolLogs, rhs: BuildEventStream_BuildToolLogs) -> Bool {
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlinksIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlinksIdentified"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "convenience_symlinks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.convenienceSymlinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.convenienceSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convenienceSymlinks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlinksIdentified, rhs: BuildEventStream_ConvenienceSymlinksIdentified) -> Bool {
    if lhs.convenienceSymlinks != rhs.convenienceSymlinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "action"),
    3: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlink, rhs: BuildEventStream_ConvenienceSymlink) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.action != rhs.action {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "DELETE"),
  ]
}

extension BuildEventStream_BuildEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "children"),
    20: .standard(proto: "last_message"),
    3: .same(proto: "progress"),
    4: .same(proto: "aborted"),
    5: .same(proto: "started"),
    12: .standard(proto: "unstructured_command_line"),
    22: .standard(proto: "structured_command_line"),
    13: .standard(proto: "options_parsed"),
    16: .standard(proto: "workspace_status"),
    21: .same(proto: "fetch"),
    17: .same(proto: "configuration"),
    6: .same(proto: "expanded"),
    18: .same(proto: "configured"),
    7: .same(proto: "action"),
    15: .standard(proto: "named_set_of_files"),
    8: .same(proto: "completed"),
    10: .standard(proto: "test_result"),
    9: .standard(proto: "test_summary"),
    14: .same(proto: "finished"),
    23: .standard(proto: "build_tool_logs"),
    24: .standard(proto: "build_metrics"),
    25: .standard(proto: "workspace_info"),
    26: .standard(proto: "build_metadata"),
    27: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId? = nil
    var _children: [BuildEventStream_BuildEventId] = []
    var _lastMessage: Bool = false
    var _payload: BuildEventStream_BuildEvent.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _children = source._children
      _lastMessage = source._lastMessage
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        case 3: try {
          var v: BuildEventStream_Progress?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .progress(v)
          }
        }()
        case 4: try {
          var v: BuildEventStream_Aborted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .aborted(v)
          }
        }()
        case 5: try {
          var v: BuildEventStream_BuildStarted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .started(v)
          }
        }()
        case 6: try {
          var v: BuildEventStream_PatternExpanded?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .expanded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .expanded(v)
          }
        }()
        case 7: try {
          var v: BuildEventStream_ActionExecuted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .action(v)
          }
        }()
        case 8: try {
          var v: BuildEventStream_TargetComplete?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .completed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .completed(v)
          }
        }()
        case 9: try {
          var v: BuildEventStream_TestSummary?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .testSummary(v)
          }
        }()
        case 10: try {
          var v: BuildEventStream_TestResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .testResult(v)
          }
        }()
        case 12: try {
          var v: BuildEventStream_UnstructuredCommandLine?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .unstructuredCommandLine(v)
          }
        }()
        case 13: try {
          var v: BuildEventStream_OptionsParsed?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .optionsParsed(v)
          }
        }()
        case 14: try {
          var v: BuildEventStream_BuildFinished?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .finished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .finished(v)
          }
        }()
        case 15: try {
          var v: BuildEventStream_NamedSetOfFiles?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .namedSetOfFiles(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .namedSetOfFiles(v)
          }
        }()
        case 16: try {
          var v: BuildEventStream_WorkspaceStatus?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workspaceStatus(v)
          }
        }()
        case 17: try {
          var v: BuildEventStream_Configuration?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .configuration(v)
          }
        }()
        case 18: try {
          var v: BuildEventStream_TargetConfigured?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .configured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .configured(v)
          }
        }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._lastMessage) }()
        case 21: try {
          var v: BuildEventStream_Fetch?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .fetch(v)
          }
        }()
        case 22: try {
          var v: CommandLine_CommandLine?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .structuredCommandLine(v)
          }
        }()
        case 23: try {
          var v: BuildEventStream_BuildToolLogs?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildToolLogs(v)
          }
        }()
        case 24: try {
          var v: BuildEventStream_BuildMetrics?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildMetrics(v)
          }
        }()
        case 25: try {
          var v: BuildEventStream_WorkspaceConfig?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workspaceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workspaceInfo(v)
          }
        }()
        case 26: try {
          var v: BuildEventStream_BuildMetadata?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildMetadata(v)
          }
        }()
        case 27: try {
          var v: BuildEventStream_ConvenienceSymlinksIdentified?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .convenienceSymlinksIdentified(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 2)
      }
      switch _storage._payload {
      case .progress?: try {
        guard case .progress(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .aborted?: try {
        guard case .aborted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .started?: try {
        guard case .started(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .expanded?: try {
        guard case .expanded(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .action?: try {
        guard case .action(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .completed?: try {
        guard case .completed(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .testSummary?: try {
        guard case .testSummary(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .testResult?: try {
        guard case .testResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .unstructuredCommandLine?: try {
        guard case .unstructuredCommandLine(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .optionsParsed?: try {
        guard case .optionsParsed(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .finished?: try {
        guard case .finished(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .namedSetOfFiles?: try {
        guard case .namedSetOfFiles(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .workspaceStatus?: try {
        guard case .workspaceStatus(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .configuration?: try {
        guard case .configuration(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .configured?: try {
        guard case .configured(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      default: break
      }
      if _storage._lastMessage != false {
        try visitor.visitSingularBoolField(value: _storage._lastMessage, fieldNumber: 20)
      }
      switch _storage._payload {
      case .fetch?: try {
        guard case .fetch(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .structuredCommandLine?: try {
        guard case .structuredCommandLine(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .buildToolLogs?: try {
        guard case .buildToolLogs(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .buildMetrics?: try {
        guard case .buildMetrics(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .workspaceInfo?: try {
        guard case .workspaceInfo(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .buildMetadata?: try {
        guard case .buildMetadata(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .convenienceSymlinksIdentified?: try {
        guard case .convenienceSymlinksIdentified(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEvent, rhs: BuildEventStream_BuildEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
