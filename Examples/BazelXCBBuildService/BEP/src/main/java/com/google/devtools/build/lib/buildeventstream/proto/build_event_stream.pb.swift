// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

import src_main_protobuf_command_line_proto
import src_main_protobuf_failure_details_proto
import src_main_protobuf_invocation_policy_proto

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum BuildEventStream_TestSize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case small // = 1
  case medium // = 2
  case large // = 3
  case enormous // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .small
    case 2: self = .medium
    case 3: self = .large
    case 4: self = .enormous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .small: return 1
    case .medium: return 2
    case .large: return 3
    case .enormous: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestSize] = [
    .unknown,
    .small,
    .medium,
    .large,
    .enormous,
  ]
}

#endif  // swift(>=4.2)

public enum BuildEventStream_TestStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noStatus // = 0
  case passed // = 1
  case flaky // = 2
  case timeout // = 3
  case failed // = 4
  case incomplete // = 5
  case remoteFailure // = 6
  case failedToBuild // = 7
  case toolHaltedBeforeTesting // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStatus
    case 1: self = .passed
    case 2: self = .flaky
    case 3: self = .timeout
    case 4: self = .failed
    case 5: self = .incomplete
    case 6: self = .remoteFailure
    case 7: self = .failedToBuild
    case 8: self = .toolHaltedBeforeTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStatus: return 0
    case .passed: return 1
    case .flaky: return 2
    case .timeout: return 3
    case .failed: return 4
    case .incomplete: return 5
    case .remoteFailure: return 6
    case .failedToBuild: return 7
    case .toolHaltedBeforeTesting: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestStatus] = [
    .noStatus,
    .passed,
    .flaky,
    .timeout,
    .failed,
    .incomplete,
    .remoteFailure,
    .failedToBuild,
    .toolHaltedBeforeTesting,
  ]
}

#endif  // swift(>=4.2)

public struct BuildEventStream_BuildEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: OneOf_ID? {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var unknown: BuildEventStream_BuildEventId.UnknownBuildEventId {
    get {
      if case .unknown(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnknownBuildEventId()
    }
    set {_uniqueStorage()._id = .unknown(newValue)}
  }

  public var progress: BuildEventStream_BuildEventId.ProgressId {
    get {
      if case .progress(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ProgressId()
    }
    set {_uniqueStorage()._id = .progress(newValue)}
  }

  public var started: BuildEventStream_BuildEventId.BuildStartedId {
    get {
      if case .started(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildStartedId()
    }
    set {_uniqueStorage()._id = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_BuildEventId.UnstructuredCommandLineId {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnstructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: BuildEventStream_BuildEventId.StructuredCommandLineId {
    get {
      if case .structuredCommandLine(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.StructuredCommandLineId()
    }
    set {_uniqueStorage()._id = .structuredCommandLine(newValue)}
  }

  public var workspaceStatus: BuildEventStream_BuildEventId.WorkspaceStatusId {
    get {
      if case .workspaceStatus(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.WorkspaceStatusId()
    }
    set {_uniqueStorage()._id = .workspaceStatus(newValue)}
  }

  public var optionsParsed: BuildEventStream_BuildEventId.OptionsParsedId {
    get {
      if case .optionsParsed(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.OptionsParsedId()
    }
    set {_uniqueStorage()._id = .optionsParsed(newValue)}
  }

  public var fetch: BuildEventStream_BuildEventId.FetchId {
    get {
      if case .fetch(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.FetchId()
    }
    set {_uniqueStorage()._id = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {
      if case .configuration(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfigurationId()
    }
    set {_uniqueStorage()._id = .configuration(newValue)}
  }

  public var targetConfigured: BuildEventStream_BuildEventId.TargetConfiguredId {
    get {
      if case .targetConfigured(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetConfiguredId()
    }
    set {_uniqueStorage()._id = .targetConfigured(newValue)}
  }

  public var pattern: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .pattern(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .pattern(newValue)}
  }

  public var patternSkipped: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .patternSkipped(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {_uniqueStorage()._id = .patternSkipped(newValue)}
  }

  public var namedSet: BuildEventStream_BuildEventId.NamedSetOfFilesId {
    get {
      if case .namedSet(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.NamedSetOfFilesId()
    }
    set {_uniqueStorage()._id = .namedSet(newValue)}
  }

  public var targetCompleted: BuildEventStream_BuildEventId.TargetCompletedId {
    get {
      if case .targetCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TargetCompletedId()
    }
    set {_uniqueStorage()._id = .targetCompleted(newValue)}
  }

  public var actionCompleted: BuildEventStream_BuildEventId.ActionCompletedId {
    get {
      if case .actionCompleted(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ActionCompletedId()
    }
    set {_uniqueStorage()._id = .actionCompleted(newValue)}
  }

  public var unconfiguredLabel: BuildEventStream_BuildEventId.UnconfiguredLabelId {
    get {
      if case .unconfiguredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.UnconfiguredLabelId()
    }
    set {_uniqueStorage()._id = .unconfiguredLabel(newValue)}
  }

  public var configuredLabel: BuildEventStream_BuildEventId.ConfiguredLabelId {
    get {
      if case .configuredLabel(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConfiguredLabelId()
    }
    set {_uniqueStorage()._id = .configuredLabel(newValue)}
  }

  public var testResult: BuildEventStream_BuildEventId.TestResultId {
    get {
      if case .testResult(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestResultId()
    }
    set {_uniqueStorage()._id = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_BuildEventId.TestSummaryId {
    get {
      if case .testSummary(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.TestSummaryId()
    }
    set {_uniqueStorage()._id = .testSummary(newValue)}
  }

  public var buildFinished: BuildEventStream_BuildEventId.BuildFinishedId {
    get {
      if case .buildFinished(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildFinishedId()
    }
    set {_uniqueStorage()._id = .buildFinished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildEventId.BuildToolLogsId {
    get {
      if case .buildToolLogs(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildToolLogsId()
    }
    set {_uniqueStorage()._id = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildEventId.BuildMetricsId {
    get {
      if case .buildMetrics(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildMetricsId()
    }
    set {_uniqueStorage()._id = .buildMetrics(newValue)}
  }

  public var workspace: BuildEventStream_BuildEventId.WorkspaceConfigId {
    get {
      if case .workspace(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.WorkspaceConfigId()
    }
    set {_uniqueStorage()._id = .workspace(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildEventId.BuildMetadataId {
    get {
      if case .buildMetadata(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.BuildMetadataId()
    }
    set {_uniqueStorage()._id = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._id {return v}
      return BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId()
    }
    set {_uniqueStorage()._id = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    case unknown(BuildEventStream_BuildEventId.UnknownBuildEventId)
    case progress(BuildEventStream_BuildEventId.ProgressId)
    case started(BuildEventStream_BuildEventId.BuildStartedId)
    case unstructuredCommandLine(BuildEventStream_BuildEventId.UnstructuredCommandLineId)
    case structuredCommandLine(BuildEventStream_BuildEventId.StructuredCommandLineId)
    case workspaceStatus(BuildEventStream_BuildEventId.WorkspaceStatusId)
    case optionsParsed(BuildEventStream_BuildEventId.OptionsParsedId)
    case fetch(BuildEventStream_BuildEventId.FetchId)
    case configuration(BuildEventStream_BuildEventId.ConfigurationId)
    case targetConfigured(BuildEventStream_BuildEventId.TargetConfiguredId)
    case pattern(BuildEventStream_BuildEventId.PatternExpandedId)
    case patternSkipped(BuildEventStream_BuildEventId.PatternExpandedId)
    case namedSet(BuildEventStream_BuildEventId.NamedSetOfFilesId)
    case targetCompleted(BuildEventStream_BuildEventId.TargetCompletedId)
    case actionCompleted(BuildEventStream_BuildEventId.ActionCompletedId)
    case unconfiguredLabel(BuildEventStream_BuildEventId.UnconfiguredLabelId)
    case configuredLabel(BuildEventStream_BuildEventId.ConfiguredLabelId)
    case testResult(BuildEventStream_BuildEventId.TestResultId)
    case testSummary(BuildEventStream_BuildEventId.TestSummaryId)
    case buildFinished(BuildEventStream_BuildEventId.BuildFinishedId)
    case buildToolLogs(BuildEventStream_BuildEventId.BuildToolLogsId)
    case buildMetrics(BuildEventStream_BuildEventId.BuildMetricsId)
    case workspace(BuildEventStream_BuildEventId.WorkspaceConfigId)
    case buildMetadata(BuildEventStream_BuildEventId.BuildMetadataId)
    case convenienceSymlinksIdentified(BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEventId.OneOf_ID, rhs: BuildEventStream_BuildEventId.OneOf_ID) -> Bool {
      switch (lhs, rhs) {
      case (.unknown(let l), .unknown(let r)): return l == r
      case (.progress(let l), .progress(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.targetConfigured(let l), .targetConfigured(let r)): return l == r
      case (.pattern(let l), .pattern(let r)): return l == r
      case (.patternSkipped(let l), .patternSkipped(let r)): return l == r
      case (.namedSet(let l), .namedSet(let r)): return l == r
      case (.targetCompleted(let l), .targetCompleted(let r)): return l == r
      case (.actionCompleted(let l), .actionCompleted(let r)): return l == r
      case (.unconfiguredLabel(let l), .unconfiguredLabel(let r)): return l == r
      case (.configuredLabel(let l), .configuredLabel(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.buildFinished(let l), .buildFinished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      case (.workspace(let l), .workspace(let r)): return l == r
      case (.buildMetadata(let l), .buildMetadata(let r)): return l == r
      case (.convenienceSymlinksIdentified(let l), .convenienceSymlinksIdentified(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct UnknownBuildEventId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ProgressId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var opaqueCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildStartedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UnstructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct StructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var commandLineLabel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WorkspaceStatusId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct OptionsParsedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct FetchId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PatternExpandedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pattern: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WorkspaceConfigId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildMetadataId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TargetConfiguredId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct NamedSetOfFilesId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ConfigurationId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TargetCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var aspect: String {
      get {return _storage._aspect}
      set {_uniqueStorage()._aspect = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ActionCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var primaryOutput: String {
      get {return _storage._primaryOutput}
      set {_uniqueStorage()._primaryOutput = newValue}
    }

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct UnconfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ConfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct TestResultId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var run: Int32 {
      get {return _storage._run}
      set {_uniqueStorage()._run = newValue}
    }

    public var shard: Int32 {
      get {return _storage._shard}
      set {_uniqueStorage()._shard = newValue}
    }

    public var attempt: Int32 {
      get {return _storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct TestSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String {
      get {return _storage._label}
      set {_uniqueStorage()._label = newValue}
    }

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_uniqueStorage()._configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return _storage._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct BuildFinishedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildToolLogsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildMetricsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ConvenienceSymlinksIdentifiedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stdout: String = String()

  public var stderr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: BuildEventStream_Aborted.AbortReason = .unknown

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AbortReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case userInterrupted // = 1
    case noAnalyze // = 8
    case noBuild // = 9
    case timeOut // = 2
    case remoteEnvironmentFailure // = 3
    case `internal` // = 4
    case loadingFailure // = 5
    case analysisFailure // = 6
    case skipped // = 7
    case incomplete // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userInterrupted
      case 2: self = .timeOut
      case 3: self = .remoteEnvironmentFailure
      case 4: self = .internal
      case 5: self = .loadingFailure
      case 6: self = .analysisFailure
      case 7: self = .skipped
      case 8: self = .noAnalyze
      case 9: self = .noBuild
      case 10: self = .incomplete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userInterrupted: return 1
      case .timeOut: return 2
      case .remoteEnvironmentFailure: return 3
      case .internal: return 4
      case .loadingFailure: return 5
      case .analysisFailure: return 6
      case .skipped: return 7
      case .noAnalyze: return 8
      case .noBuild: return 9
      case .incomplete: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_Aborted.AbortReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_Aborted.AbortReason] = [
    .unknown,
    .userInterrupted,
    .noAnalyze,
    .noBuild,
    .timeOut,
    .remoteEnvironmentFailure,
    .internal,
    .loadingFailure,
    .analysisFailure,
    .skipped,
    .incomplete,
  ]
}

#endif  // swift(>=4.2)

public struct BuildEventStream_BuildStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  public var startTimeMillis: Int64 = 0

  public var buildToolVersion: String = String()

  public var optionsDescription: String = String()

  public var command: String = String()

  public var workingDirectory: String = String()

  public var workspaceDirectory: String = String()

  public var serverPid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_WorkspaceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var localExecRoot: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_UnstructuredCommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_OptionsParsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startupOptions: [String] {
    get {return _storage._startupOptions}
    set {_uniqueStorage()._startupOptions = newValue}
  }

  public var explicitStartupOptions: [String] {
    get {return _storage._explicitStartupOptions}
    set {_uniqueStorage()._explicitStartupOptions = newValue}
  }

  public var cmdLine: [String] {
    get {return _storage._cmdLine}
    set {_uniqueStorage()._cmdLine = newValue}
  }

  public var explicitCmdLine: [String] {
    get {return _storage._explicitCmdLine}
    set {_uniqueStorage()._explicitCmdLine = newValue}
  }

  public var invocationPolicy: src_main_protobuf_invocation_policy_proto.Blaze_InvocationPolicy_InvocationPolicy {
    get {return _storage._invocationPolicy ?? src_main_protobuf_invocation_policy_proto.Blaze_InvocationPolicy_InvocationPolicy()}
    set {_uniqueStorage()._invocationPolicy = newValue}
  }
  /// Returns true if `invocationPolicy` has been explicitly set.
  public var hasInvocationPolicy: Bool {return _storage._invocationPolicy != nil}
  /// Clears the value of `invocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationPolicy() {_uniqueStorage()._invocationPolicy = nil}

  public var toolTag: String {
    get {return _storage._toolTag}
    set {_uniqueStorage()._toolTag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_Fetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [BuildEventStream_WorkspaceStatus.Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct BuildEventStream_BuildMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var metadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mnemonic: String = String()

  public var platformName: String = String()

  public var cpu: String = String()

  public var makeVariable: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_PatternExpanded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_TargetConfigured {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetKind: String = String()

  public var testSize: BuildEventStream_TestSize = .unknown

  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathPrefix: [String] = []

  public var name: String = String()

  public var file: BuildEventStream_File.OneOf_File? = nil

  public var uri: String {
    get {
      if case .uri(let v)? = file {return v}
      return String()
    }
    set {file = .uri(newValue)}
  }

  public var contents: Data {
    get {
      if case .contents(let v)? = file {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {file = .contents(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_File: Equatable {
    case uri(String)
    case contents(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_File.OneOf_File, rhs: BuildEventStream_File.OneOf_File) -> Bool {
      switch (lhs, rhs) {
      case (.uri(let l), .uri(let r)): return l == r
      case (.contents(let l), .contents(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct BuildEventStream_NamedSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var files: [BuildEventStream_File] = []

  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_ActionExecuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  public var stdout: BuildEventStream_File {
    get {return _storage._stdout ?? BuildEventStream_File()}
    set {_uniqueStorage()._stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  public var hasStdout: Bool {return _storage._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  public mutating func clearStdout() {_uniqueStorage()._stdout = nil}

  public var stderr: BuildEventStream_File {
    get {return _storage._stderr ?? BuildEventStream_File()}
    set {_uniqueStorage()._stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return _storage._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {_uniqueStorage()._stderr = nil}

  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  public var primaryOutput: BuildEventStream_File {
    get {return _storage._primaryOutput ?? BuildEventStream_File()}
    set {_uniqueStorage()._primaryOutput = newValue}
  }
  /// Returns true if `primaryOutput` has been explicitly set.
  public var hasPrimaryOutput: Bool {return _storage._primaryOutput != nil}
  /// Clears the value of `primaryOutput`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryOutput() {_uniqueStorage()._primaryOutput = nil}

  public var commandLine: [String] {
    get {return _storage._commandLine}
    set {_uniqueStorage()._commandLine = newValue}
  }

  public var actionMetadataLogs: [BuildEventStream_File] {
    get {return _storage._actionMetadataLogs}
    set {_uniqueStorage()._actionMetadataLogs = newValue}
  }

  public var failureDetail: src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_OutputGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_TargetComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  public var targetKind: String {
    get {return _storage._targetKind}
    set {_uniqueStorage()._targetKind = newValue}
  }

  public var testSize: BuildEventStream_TestSize {
    get {return _storage._testSize}
    set {_uniqueStorage()._testSize = newValue}
  }

  public var outputGroup: [BuildEventStream_OutputGroup] {
    get {return _storage._outputGroup}
    set {_uniqueStorage()._outputGroup = newValue}
  }

  public var importantOutput: [BuildEventStream_File] {
    get {return _storage._importantOutput}
    set {_uniqueStorage()._importantOutput = newValue}
  }

  public var directoryOutput: [BuildEventStream_File] {
    get {return _storage._directoryOutput}
    set {_uniqueStorage()._directoryOutput = newValue}
  }

  public var tag: [String] {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  public var testTimeoutSeconds: Int64 {
    get {return _storage._testTimeoutSeconds}
    set {_uniqueStorage()._testTimeoutSeconds = newValue}
  }

  public var failureDetail: src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_TestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: BuildEventStream_TestStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var statusDetails: String {
    get {return _storage._statusDetails}
    set {_uniqueStorage()._statusDetails = newValue}
  }

  public var cachedLocally: Bool {
    get {return _storage._cachedLocally}
    set {_uniqueStorage()._cachedLocally = newValue}
  }

  public var testAttemptStartMillisEpoch: Int64 {
    get {return _storage._testAttemptStartMillisEpoch}
    set {_uniqueStorage()._testAttemptStartMillisEpoch = newValue}
  }

  public var testAttemptDurationMillis: Int64 {
    get {return _storage._testAttemptDurationMillis}
    set {_uniqueStorage()._testAttemptDurationMillis = newValue}
  }

  public var testActionOutput: [BuildEventStream_File] {
    get {return _storage._testActionOutput}
    set {_uniqueStorage()._testActionOutput = newValue}
  }

  public var warning: [String] {
    get {return _storage._warning}
    set {_uniqueStorage()._warning = newValue}
  }

  public var executionInfo: BuildEventStream_TestResult.ExecutionInfo {
    get {return _storage._executionInfo ?? BuildEventStream_TestResult.ExecutionInfo()}
    set {_uniqueStorage()._executionInfo = newValue}
  }
  /// Returns true if `executionInfo` has been explicitly set.
  public var hasExecutionInfo: Bool {return _storage._executionInfo != nil}
  /// Clears the value of `executionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionInfo() {_uniqueStorage()._executionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ExecutionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timeoutSeconds: Int32 {
      get {return _storage._timeoutSeconds}
      set {_uniqueStorage()._timeoutSeconds = newValue}
    }

    public var strategy: String {
      get {return _storage._strategy}
      set {_uniqueStorage()._strategy = newValue}
    }

    public var cachedRemotely: Bool {
      get {return _storage._cachedRemotely}
      set {_uniqueStorage()._cachedRemotely = newValue}
    }

    public var exitCode: Int32 {
      get {return _storage._exitCode}
      set {_uniqueStorage()._exitCode = newValue}
    }

    public var hostname: String {
      get {return _storage._hostname}
      set {_uniqueStorage()._hostname = newValue}
    }

    public var timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown {
      get {return _storage._timingBreakdown ?? BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown()}
      set {_uniqueStorage()._timingBreakdown = newValue}
    }
    /// Returns true if `timingBreakdown` has been explicitly set.
    public var hasTimingBreakdown: Bool {return _storage._timingBreakdown != nil}
    /// Clears the value of `timingBreakdown`. Subsequent reads from it will return its default value.
    public mutating func clearTimingBreakdown() {_uniqueStorage()._timingBreakdown = nil}

    public var resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] {
      get {return _storage._resourceUsage}
      set {_uniqueStorage()._resourceUsage = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct TimingBreakdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var child: [BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown] = []

      public var name: String = String()

      public var timeMillis: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct ResourceUsage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_TestSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var overallStatus: BuildEventStream_TestStatus = .noStatus

  public var totalRunCount: Int32 = 0

  public var passed: [BuildEventStream_File] = []

  public var failed: [BuildEventStream_File] = []

  public var totalNumCached: Int32 = 0

  public var firstStartTimeMillis: Int64 = 0

  public var lastStopTimeMillis: Int64 = 0

  public var totalRunDurationMillis: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_BuildFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var overallSuccess: Bool {
    get {return _storage._overallSuccess}
    set {_uniqueStorage()._overallSuccess = newValue}
  }

  public var exitCode: BuildEventStream_BuildFinished.ExitCode {
    get {return _storage._exitCode ?? BuildEventStream_BuildFinished.ExitCode()}
    set {_uniqueStorage()._exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return _storage._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {_uniqueStorage()._exitCode = nil}

  public var finishTimeMillis: Int64 {
    get {return _storage._finishTimeMillis}
    set {_uniqueStorage()._finishTimeMillis = newValue}
  }

  public var anomalyReport: BuildEventStream_BuildFinished.AnomalyReport {
    get {return _storage._anomalyReport ?? BuildEventStream_BuildFinished.AnomalyReport()}
    set {_uniqueStorage()._anomalyReport = newValue}
  }
  /// Returns true if `anomalyReport` has been explicitly set.
  public var hasAnomalyReport: Bool {return _storage._anomalyReport != nil}
  /// Clears the value of `anomalyReport`. Subsequent reads from it will return its default value.
  public mutating func clearAnomalyReport() {_uniqueStorage()._anomalyReport = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ExitCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var code: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AnomalyReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var wasSuspended: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_BuildMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionSummary: BuildEventStream_BuildMetrics.ActionSummary {
    get {return _storage._actionSummary ?? BuildEventStream_BuildMetrics.ActionSummary()}
    set {_uniqueStorage()._actionSummary = newValue}
  }
  /// Returns true if `actionSummary` has been explicitly set.
  public var hasActionSummary: Bool {return _storage._actionSummary != nil}
  /// Clears the value of `actionSummary`. Subsequent reads from it will return its default value.
  public mutating func clearActionSummary() {_uniqueStorage()._actionSummary = nil}

  public var memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics {
    get {return _storage._memoryMetrics ?? BuildEventStream_BuildMetrics.MemoryMetrics()}
    set {_uniqueStorage()._memoryMetrics = newValue}
  }
  /// Returns true if `memoryMetrics` has been explicitly set.
  public var hasMemoryMetrics: Bool {return _storage._memoryMetrics != nil}
  /// Clears the value of `memoryMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearMemoryMetrics() {_uniqueStorage()._memoryMetrics = nil}

  public var targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics {
    get {return _storage._targetMetrics ?? BuildEventStream_BuildMetrics.TargetMetrics()}
    set {_uniqueStorage()._targetMetrics = newValue}
  }
  /// Returns true if `targetMetrics` has been explicitly set.
  public var hasTargetMetrics: Bool {return _storage._targetMetrics != nil}
  /// Clears the value of `targetMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTargetMetrics() {_uniqueStorage()._targetMetrics = nil}

  public var packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics {
    get {return _storage._packageMetrics ?? BuildEventStream_BuildMetrics.PackageMetrics()}
    set {_uniqueStorage()._packageMetrics = newValue}
  }
  /// Returns true if `packageMetrics` has been explicitly set.
  public var hasPackageMetrics: Bool {return _storage._packageMetrics != nil}
  /// Clears the value of `packageMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearPackageMetrics() {_uniqueStorage()._packageMetrics = nil}

  public var timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics {
    get {return _storage._timingMetrics ?? BuildEventStream_BuildMetrics.TimingMetrics()}
    set {_uniqueStorage()._timingMetrics = newValue}
  }
  /// Returns true if `timingMetrics` has been explicitly set.
  public var hasTimingMetrics: Bool {return _storage._timingMetrics != nil}
  /// Clears the value of `timingMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTimingMetrics() {_uniqueStorage()._timingMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ActionSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionsCreated: Int64 = 0

    public var actionsExecuted: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MemoryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var usedHeapSizePostBuild: Int64 = 0

    public var peakPostGcHeapSize: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TargetMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var targetsLoaded: Int64 = 0

    public var targetsConfigured: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PackageMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var packagesLoaded: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TimingMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var cpuTimeInMs: Int64 = 0

    public var wallTimeInMs: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BuildEventStream_BuildToolLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: [BuildEventStream_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_ConvenienceSymlinksIdentified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var convenienceSymlinks: [BuildEventStream_ConvenienceSymlink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_ConvenienceSymlink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var action: BuildEventStream_ConvenienceSymlink.Action = .unknown

  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case create // = 1
    case delete // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .create
      case 2: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .create: return 1
      case .delete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_ConvenienceSymlink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_ConvenienceSymlink.Action] = [
    .unknown,
    .create,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct BuildEventStream_BuildEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId {
    get {return _storage._id ?? BuildEventStream_BuildEventId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var children: [BuildEventStream_BuildEventId] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var lastMessage: Bool {
    get {return _storage._lastMessage}
    set {_uniqueStorage()._lastMessage = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var progress: BuildEventStream_Progress {
    get {
      if case .progress(let v)? = _storage._payload {return v}
      return BuildEventStream_Progress()
    }
    set {_uniqueStorage()._payload = .progress(newValue)}
  }

  public var aborted: BuildEventStream_Aborted {
    get {
      if case .aborted(let v)? = _storage._payload {return v}
      return BuildEventStream_Aborted()
    }
    set {_uniqueStorage()._payload = .aborted(newValue)}
  }

  public var started: BuildEventStream_BuildStarted {
    get {
      if case .started(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildStarted()
    }
    set {_uniqueStorage()._payload = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_UnstructuredCommandLine {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._payload {return v}
      return BuildEventStream_UnstructuredCommandLine()
    }
    set {_uniqueStorage()._payload = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: src_main_protobuf_command_line_proto.CommandLine_CommandLine {
    get {
      if case .structuredCommandLine(let v)? = _storage._payload {return v}
      return src_main_protobuf_command_line_proto.CommandLine_CommandLine()
    }
    set {_uniqueStorage()._payload = .structuredCommandLine(newValue)}
  }

  public var optionsParsed: BuildEventStream_OptionsParsed {
    get {
      if case .optionsParsed(let v)? = _storage._payload {return v}
      return BuildEventStream_OptionsParsed()
    }
    set {_uniqueStorage()._payload = .optionsParsed(newValue)}
  }

  public var workspaceStatus: BuildEventStream_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceStatus()
    }
    set {_uniqueStorage()._payload = .workspaceStatus(newValue)}
  }

  public var fetch: BuildEventStream_Fetch {
    get {
      if case .fetch(let v)? = _storage._payload {return v}
      return BuildEventStream_Fetch()
    }
    set {_uniqueStorage()._payload = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_Configuration {
    get {
      if case .configuration(let v)? = _storage._payload {return v}
      return BuildEventStream_Configuration()
    }
    set {_uniqueStorage()._payload = .configuration(newValue)}
  }

  public var expanded: BuildEventStream_PatternExpanded {
    get {
      if case .expanded(let v)? = _storage._payload {return v}
      return BuildEventStream_PatternExpanded()
    }
    set {_uniqueStorage()._payload = .expanded(newValue)}
  }

  public var configured: BuildEventStream_TargetConfigured {
    get {
      if case .configured(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetConfigured()
    }
    set {_uniqueStorage()._payload = .configured(newValue)}
  }

  public var action: BuildEventStream_ActionExecuted {
    get {
      if case .action(let v)? = _storage._payload {return v}
      return BuildEventStream_ActionExecuted()
    }
    set {_uniqueStorage()._payload = .action(newValue)}
  }

  public var namedSetOfFiles: BuildEventStream_NamedSetOfFiles {
    get {
      if case .namedSetOfFiles(let v)? = _storage._payload {return v}
      return BuildEventStream_NamedSetOfFiles()
    }
    set {_uniqueStorage()._payload = .namedSetOfFiles(newValue)}
  }

  public var completed: BuildEventStream_TargetComplete {
    get {
      if case .completed(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetComplete()
    }
    set {_uniqueStorage()._payload = .completed(newValue)}
  }

  public var testResult: BuildEventStream_TestResult {
    get {
      if case .testResult(let v)? = _storage._payload {return v}
      return BuildEventStream_TestResult()
    }
    set {_uniqueStorage()._payload = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_TestSummary {
    get {
      if case .testSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TestSummary()
    }
    set {_uniqueStorage()._payload = .testSummary(newValue)}
  }

  public var finished: BuildEventStream_BuildFinished {
    get {
      if case .finished(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildFinished()
    }
    set {_uniqueStorage()._payload = .finished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildToolLogs {
    get {
      if case .buildToolLogs(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildToolLogs()
    }
    set {_uniqueStorage()._payload = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildMetrics {
    get {
      if case .buildMetrics(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetrics()
    }
    set {_uniqueStorage()._payload = .buildMetrics(newValue)}
  }

  public var workspaceInfo: BuildEventStream_WorkspaceConfig {
    get {
      if case .workspaceInfo(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceConfig()
    }
    set {_uniqueStorage()._payload = .workspaceInfo(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildMetadata {
    get {
      if case .buildMetadata(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetadata()
    }
    set {_uniqueStorage()._payload = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_ConvenienceSymlinksIdentified {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._payload {return v}
      return BuildEventStream_ConvenienceSymlinksIdentified()
    }
    set {_uniqueStorage()._payload = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case progress(BuildEventStream_Progress)
    case aborted(BuildEventStream_Aborted)
    case started(BuildEventStream_BuildStarted)
    case unstructuredCommandLine(BuildEventStream_UnstructuredCommandLine)
    case structuredCommandLine(src_main_protobuf_command_line_proto.CommandLine_CommandLine)
    case optionsParsed(BuildEventStream_OptionsParsed)
    case workspaceStatus(BuildEventStream_WorkspaceStatus)
    case fetch(BuildEventStream_Fetch)
    case configuration(BuildEventStream_Configuration)
    case expanded(BuildEventStream_PatternExpanded)
    case configured(BuildEventStream_TargetConfigured)
    case action(BuildEventStream_ActionExecuted)
    case namedSetOfFiles(BuildEventStream_NamedSetOfFiles)
    case completed(BuildEventStream_TargetComplete)
    case testResult(BuildEventStream_TestResult)
    case testSummary(BuildEventStream_TestSummary)
    case finished(BuildEventStream_BuildFinished)
    case buildToolLogs(BuildEventStream_BuildToolLogs)
    case buildMetrics(BuildEventStream_BuildMetrics)
    case workspaceInfo(BuildEventStream_WorkspaceConfig)
    case buildMetadata(BuildEventStream_BuildMetadata)
    case convenienceSymlinksIdentified(BuildEventStream_ConvenienceSymlinksIdentified)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEvent.OneOf_Payload, rhs: BuildEventStream_BuildEvent.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.progress(let l), .progress(let r)): return l == r
      case (.aborted(let l), .aborted(let r)): return l == r
      case (.started(let l), .started(let r)): return l == r
      case (.unstructuredCommandLine(let l), .unstructuredCommandLine(let r)): return l == r
      case (.structuredCommandLine(let l), .structuredCommandLine(let r)): return l == r
      case (.optionsParsed(let l), .optionsParsed(let r)): return l == r
      case (.workspaceStatus(let l), .workspaceStatus(let r)): return l == r
      case (.fetch(let l), .fetch(let r)): return l == r
      case (.configuration(let l), .configuration(let r)): return l == r
      case (.expanded(let l), .expanded(let r)): return l == r
      case (.configured(let l), .configured(let r)): return l == r
      case (.action(let l), .action(let r)): return l == r
      case (.namedSetOfFiles(let l), .namedSetOfFiles(let r)): return l == r
      case (.completed(let l), .completed(let r)): return l == r
      case (.testResult(let l), .testResult(let r)): return l == r
      case (.testSummary(let l), .testSummary(let r)): return l == r
      case (.finished(let l), .finished(let r)): return l == r
      case (.buildToolLogs(let l), .buildToolLogs(let r)): return l == r
      case (.buildMetrics(let l), .buildMetrics(let r)): return l == r
      case (.workspaceInfo(let l), .workspaceInfo(let r)): return l == r
      case (.buildMetadata(let l), .buildMetadata(let r)): return l == r
      case (.convenienceSymlinksIdentified(let l), .convenienceSymlinksIdentified(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build_event_stream"

extension BuildEventStream_TestSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
    4: .same(proto: "ENORMOUS"),
  ]
}

extension BuildEventStream_TestStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STATUS"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FLAKY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "REMOTE_FAILURE"),
    7: .same(proto: "FAILED_TO_BUILD"),
    8: .same(proto: "TOOL_HALTED_BEFORE_TESTING"),
  ]
}

extension BuildEventStream_BuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "progress"),
    3: .same(proto: "started"),
    11: .standard(proto: "unstructured_command_line"),
    18: .standard(proto: "structured_command_line"),
    14: .standard(proto: "workspace_status"),
    12: .standard(proto: "options_parsed"),
    17: .same(proto: "fetch"),
    15: .same(proto: "configuration"),
    16: .standard(proto: "target_configured"),
    4: .same(proto: "pattern"),
    10: .standard(proto: "pattern_skipped"),
    13: .standard(proto: "named_set"),
    5: .standard(proto: "target_completed"),
    6: .standard(proto: "action_completed"),
    19: .standard(proto: "unconfigured_label"),
    21: .standard(proto: "configured_label"),
    8: .standard(proto: "test_result"),
    7: .standard(proto: "test_summary"),
    9: .standard(proto: "build_finished"),
    20: .standard(proto: "build_tool_logs"),
    22: .standard(proto: "build_metrics"),
    23: .same(proto: "workspace"),
    24: .standard(proto: "build_metadata"),
    25: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId.OneOf_ID?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: BuildEventStream_BuildEventId.UnknownBuildEventId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unknown(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unknown(v)}
        case 2:
          var v: BuildEventStream_BuildEventId.ProgressId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .progress(v)}
        case 3:
          var v: BuildEventStream_BuildEventId.BuildStartedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .started(v)}
        case 4:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .pattern(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .pattern(v)}
        case 5:
          var v: BuildEventStream_BuildEventId.TargetCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetCompleted(v)}
        case 6:
          var v: BuildEventStream_BuildEventId.ActionCompletedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .actionCompleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .actionCompleted(v)}
        case 7:
          var v: BuildEventStream_BuildEventId.TestSummaryId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testSummary(v)}
        case 8:
          var v: BuildEventStream_BuildEventId.TestResultId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .testResult(v)}
        case 9:
          var v: BuildEventStream_BuildEventId.BuildFinishedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildFinished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildFinished(v)}
        case 10:
          var v: BuildEventStream_BuildEventId.PatternExpandedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .patternSkipped(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .patternSkipped(v)}
        case 11:
          var v: BuildEventStream_BuildEventId.UnstructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unstructuredCommandLine(v)}
        case 12:
          var v: BuildEventStream_BuildEventId.OptionsParsedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .optionsParsed(v)}
        case 13:
          var v: BuildEventStream_BuildEventId.NamedSetOfFilesId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .namedSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .namedSet(v)}
        case 14:
          var v: BuildEventStream_BuildEventId.WorkspaceStatusId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .workspaceStatus(v)}
        case 15:
          var v: BuildEventStream_BuildEventId.ConfigurationId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuration(v)}
        case 16:
          var v: BuildEventStream_BuildEventId.TargetConfiguredId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .targetConfigured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .targetConfigured(v)}
        case 17:
          var v: BuildEventStream_BuildEventId.FetchId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .fetch(v)}
        case 18:
          var v: BuildEventStream_BuildEventId.StructuredCommandLineId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .structuredCommandLine(v)}
        case 19:
          var v: BuildEventStream_BuildEventId.UnconfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .unconfiguredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .unconfiguredLabel(v)}
        case 20:
          var v: BuildEventStream_BuildEventId.BuildToolLogsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildToolLogs(v)}
        case 21:
          var v: BuildEventStream_BuildEventId.ConfiguredLabelId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .configuredLabel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .configuredLabel(v)}
        case 22:
          var v: BuildEventStream_BuildEventId.BuildMetricsId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildMetrics(v)}
        case 23:
          var v: BuildEventStream_BuildEventId.WorkspaceConfigId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .workspace(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .workspace(v)}
        case 24:
          var v: BuildEventStream_BuildEventId.BuildMetadataId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .buildMetadata(v)}
        case 25:
          var v: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId?
          if let current = _storage._id {
            try decoder.handleConflictingOneOf()
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._id = .convenienceSymlinksIdentified(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._id {
      case .unknown(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .pattern(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .targetCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .actionCompleted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .buildFinished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .patternSkipped(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .namedSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .targetConfigured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .unconfiguredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .configuredLabel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .workspace(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .buildMetadata(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .convenienceSymlinksIdentified(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId, rhs: BuildEventStream_BuildEventId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnknownBuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnknownBuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.details)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnknownBuildEventId, rhs: BuildEventStream_BuildEventId.UnknownBuildEventId) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ProgressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ProgressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opaque_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.opaqueCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.opaqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.opaqueCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ProgressId, rhs: BuildEventStream_BuildEventId.ProgressId) -> Bool {
    if lhs.opaqueCount != rhs.opaqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildStartedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildStartedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildStartedId, rhs: BuildEventStream_BuildEventId.BuildStartedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnstructuredCommandLineId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId, rhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.StructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".StructuredCommandLineId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.commandLineLabel)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLineLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLineLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.StructuredCommandLineId, rhs: BuildEventStream_BuildEventId.StructuredCommandLineId) -> Bool {
    if lhs.commandLineLabel != rhs.commandLineLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceStatusId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceStatusId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceStatusId, rhs: BuildEventStream_BuildEventId.WorkspaceStatusId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.OptionsParsedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".OptionsParsedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.OptionsParsedId, rhs: BuildEventStream_BuildEventId.OptionsParsedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.FetchId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".FetchId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.FetchId, rhs: BuildEventStream_BuildEventId.FetchId) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.PatternExpandedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".PatternExpandedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.pattern)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.PatternExpandedId, rhs: BuildEventStream_BuildEventId.PatternExpandedId) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceConfigId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceConfigId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceConfigId, rhs: BuildEventStream_BuildEventId.WorkspaceConfigId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetadataId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetadataId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetadataId, rhs: BuildEventStream_BuildEventId.BuildMetadataId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetConfiguredId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetConfiguredId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      case 2: try decoder.decodeSingularStringField(value: &self.aspect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetConfiguredId, rhs: BuildEventStream_BuildEventId.TargetConfiguredId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.NamedSetOfFilesId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".NamedSetOfFilesId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.NamedSetOfFilesId, rhs: BuildEventStream_BuildEventId.NamedSetOfFilesId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfigurationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfigurationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfigurationId, rhs: BuildEventStream_BuildEventId.ConfigurationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    3: .same(proto: "configuration"),
    2: .same(proto: "aspect"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _aspect: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _aspect = source._aspect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularStringField(value: &_storage._aspect)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if !_storage._aspect.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aspect, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetCompletedId, rhs: BuildEventStream_BuildEventId.TargetCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._aspect != rhs_storage._aspect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ActionCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ActionCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_output"),
    2: .same(proto: "label"),
    3: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _primaryOutput: String = String()
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _primaryOutput = source._primaryOutput
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._primaryOutput)
        case 2: try decoder.decodeSingularStringField(value: &_storage._label)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._primaryOutput.isEmpty {
        try visitor.visitSingularStringField(value: _storage._primaryOutput, fieldNumber: 1)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 2)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ActionCompletedId, rhs: BuildEventStream_BuildEventId.ActionCompletedId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnconfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnconfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.label)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnconfiguredLabelId, rhs: BuildEventStream_BuildEventId.UnconfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfiguredLabelId, rhs: BuildEventStream_BuildEventId.ConfiguredLabelId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestResultId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestResultId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    5: .same(proto: "configuration"),
    2: .same(proto: "run"),
    3: .same(proto: "shard"),
    4: .same(proto: "attempt"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _run: Int32 = 0
    var _shard: Int32 = 0
    var _attempt: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
      _run = source._run
      _shard = source._shard
      _attempt = source._attempt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._run)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._shard)
        case 4: try decoder.decodeSingularInt32Field(value: &_storage._attempt)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if _storage._run != 0 {
        try visitor.visitSingularInt32Field(value: _storage._run, fieldNumber: 2)
      }
      if _storage._shard != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shard, fieldNumber: 3)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 4)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestResultId, rhs: BuildEventStream_BuildEventId.TestResultId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._run != rhs_storage._run {return false}
        if _storage._shard != rhs_storage._shard {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  fileprivate class _StorageClass {
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _configuration = source._configuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._label)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 1)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestSummaryId, rhs: BuildEventStream_BuildEventId.TestSummaryId) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildFinishedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildFinishedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildFinishedId, rhs: BuildEventStream_BuildEventId.BuildFinishedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildToolLogsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildToolLogsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildToolLogsId, rhs: BuildEventStream_BuildEventId.BuildToolLogsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetricsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetricsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetricsId, rhs: BuildEventStream_BuildEventId.BuildMetricsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConvenienceSymlinksIdentifiedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId, rhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.stdout)
      case 2: try decoder.decodeSingularStringField(value: &self.stderr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularStringField(value: self.stderr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Progress, rhs: BuildEventStream_Progress) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aborted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Aborted, rhs: BuildEventStream_Aborted) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted.AbortReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER_INTERRUPTED"),
    2: .same(proto: "TIME_OUT"),
    3: .same(proto: "REMOTE_ENVIRONMENT_FAILURE"),
    4: .same(proto: "INTERNAL"),
    5: .same(proto: "LOADING_FAILURE"),
    6: .same(proto: "ANALYSIS_FAILURE"),
    7: .same(proto: "SKIPPED"),
    8: .same(proto: "NO_ANALYZE"),
    9: .same(proto: "NO_BUILD"),
    10: .same(proto: "INCOMPLETE"),
  ]
}

extension BuildEventStream_BuildStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStarted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "start_time_millis"),
    3: .standard(proto: "build_tool_version"),
    4: .standard(proto: "options_description"),
    5: .same(proto: "command"),
    6: .standard(proto: "working_directory"),
    7: .standard(proto: "workspace_directory"),
    8: .standard(proto: "server_pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.uuid)
      case 2: try decoder.decodeSingularInt64Field(value: &self.startTimeMillis)
      case 3: try decoder.decodeSingularStringField(value: &self.buildToolVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.optionsDescription)
      case 5: try decoder.decodeSingularStringField(value: &self.command)
      case 6: try decoder.decodeSingularStringField(value: &self.workingDirectory)
      case 7: try decoder.decodeSingularStringField(value: &self.workspaceDirectory)
      case 8: try decoder.decodeSingularInt64Field(value: &self.serverPid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.startTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMillis, fieldNumber: 2)
    }
    if !self.buildToolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.buildToolVersion, fieldNumber: 3)
    }
    if !self.optionsDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionsDescription, fieldNumber: 4)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.workspaceDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDirectory, fieldNumber: 7)
    }
    if self.serverPid != 0 {
      try visitor.visitSingularInt64Field(value: self.serverPid, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildStarted, rhs: BuildEventStream_BuildStarted) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.startTimeMillis != rhs.startTimeMillis {return false}
    if lhs.buildToolVersion != rhs.buildToolVersion {return false}
    if lhs.optionsDescription != rhs.optionsDescription {return false}
    if lhs.command != rhs.command {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.workspaceDirectory != rhs.workspaceDirectory {return false}
    if lhs.serverPid != rhs.serverPid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_exec_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.localExecRoot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localExecRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.localExecRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceConfig, rhs: BuildEventStream_WorkspaceConfig) -> Bool {
    if lhs.localExecRoot != rhs.localExecRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_UnstructuredCommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnstructuredCommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.args)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_UnstructuredCommandLine, rhs: BuildEventStream_UnstructuredCommandLine) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OptionsParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionsParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "startup_options"),
    2: .standard(proto: "explicit_startup_options"),
    3: .standard(proto: "cmd_line"),
    4: .standard(proto: "explicit_cmd_line"),
    5: .standard(proto: "invocation_policy"),
    6: .standard(proto: "tool_tag"),
  ]

  fileprivate class _StorageClass {
    var _startupOptions: [String] = []
    var _explicitStartupOptions: [String] = []
    var _cmdLine: [String] = []
    var _explicitCmdLine: [String] = []
    var _invocationPolicy: src_main_protobuf_invocation_policy_proto.Blaze_InvocationPolicy_InvocationPolicy? = nil
    var _toolTag: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _startupOptions = source._startupOptions
      _explicitStartupOptions = source._explicitStartupOptions
      _cmdLine = source._cmdLine
      _explicitCmdLine = source._explicitCmdLine
      _invocationPolicy = source._invocationPolicy
      _toolTag = source._toolTag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &_storage._startupOptions)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._explicitStartupOptions)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._cmdLine)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._explicitCmdLine)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._invocationPolicy)
        case 6: try decoder.decodeSingularStringField(value: &_storage._toolTag)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._startupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._startupOptions, fieldNumber: 1)
      }
      if !_storage._explicitStartupOptions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitStartupOptions, fieldNumber: 2)
      }
      if !_storage._cmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cmdLine, fieldNumber: 3)
      }
      if !_storage._explicitCmdLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._explicitCmdLine, fieldNumber: 4)
      }
      if let v = _storage._invocationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._toolTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._toolTag, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OptionsParsed, rhs: BuildEventStream_OptionsParsed) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._startupOptions != rhs_storage._startupOptions {return false}
        if _storage._explicitStartupOptions != rhs_storage._explicitStartupOptions {return false}
        if _storage._cmdLine != rhs_storage._cmdLine {return false}
        if _storage._explicitCmdLine != rhs_storage._explicitCmdLine {return false}
        if _storage._invocationPolicy != rhs_storage._invocationPolicy {return false}
        if _storage._toolTag != rhs_storage._toolTag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fetch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.success)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Fetch, rhs: BuildEventStream_Fetch) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.item)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus, rhs: BuildEventStream_WorkspaceStatus) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_WorkspaceStatus.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus.Item, rhs: BuildEventStream_WorkspaceStatus.Item) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetadata, rhs: BuildEventStream_BuildMetadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "platform_name"),
    3: .same(proto: "cpu"),
    4: .standard(proto: "make_variable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.mnemonic)
      case 2: try decoder.decodeSingularStringField(value: &self.platformName)
      case 3: try decoder.decodeSingularStringField(value: &self.cpu)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.makeVariable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 2)
    }
    if !self.cpu.isEmpty {
      try visitor.visitSingularStringField(value: self.cpu, fieldNumber: 3)
    }
    if !self.makeVariable.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.makeVariable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Configuration, rhs: BuildEventStream_Configuration) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.cpu != rhs.cpu {return false}
    if lhs.makeVariable != rhs.makeVariable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternExpanded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded, rhs: BuildEventStream_PatternExpanded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetConfigured"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_kind"),
    2: .standard(proto: "test_size"),
    3: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.targetKind)
      case 2: try decoder.decodeSingularEnumField(value: &self.testSize)
      case 3: try decoder.decodeRepeatedStringField(value: &self.tag)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 1)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetConfigured, rhs: BuildEventStream_TargetConfigured) -> Bool {
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "path_prefix"),
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.file = .uri(v)}
      case 3:
        if self.file != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.file = .contents(v)}
      case 4: try decoder.decodeRepeatedStringField(value: &self.pathPrefix)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.file {
    case .uri(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .contents(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case nil: break
    }
    if !self.pathPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathPrefix, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_File, rhs: BuildEventStream_File) -> Bool {
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_NamedSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.files)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_NamedSetOfFiles, rhs: BuildEventStream_NamedSetOfFiles) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ActionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionExecuted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    8: .same(proto: "type"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "stdout"),
    4: .same(proto: "stderr"),
    5: .same(proto: "label"),
    7: .same(proto: "configuration"),
    6: .standard(proto: "primary_output"),
    9: .standard(proto: "command_line"),
    10: .standard(proto: "action_metadata_logs"),
    11: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _type: String = String()
    var _exitCode: Int32 = 0
    var _stdout: BuildEventStream_File? = nil
    var _stderr: BuildEventStream_File? = nil
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _primaryOutput: BuildEventStream_File? = nil
    var _commandLine: [String] = []
    var _actionMetadataLogs: [BuildEventStream_File] = []
    var _failureDetail: src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _type = source._type
      _exitCode = source._exitCode
      _stdout = source._stdout
      _stderr = source._stderr
      _label = source._label
      _configuration = source._configuration
      _primaryOutput = source._primaryOutput
      _commandLine = source._commandLine
      _actionMetadataLogs = source._actionMetadataLogs
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._success)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._stdout)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._stderr)
        case 5: try decoder.decodeSingularStringField(value: &_storage._label)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._primaryOutput)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._configuration)
        case 8: try decoder.decodeSingularStringField(value: &_storage._type)
        case 9: try decoder.decodeRepeatedStringField(value: &_storage._commandLine)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._actionMetadataLogs)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._failureDetail)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 2)
      }
      if let v = _storage._stdout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._stderr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      if let v = _storage._primaryOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._commandLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandLine, fieldNumber: 9)
      }
      if !_storage._actionMetadataLogs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionMetadataLogs, fieldNumber: 10)
      }
      if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ActionExecuted, rhs: BuildEventStream_ActionExecuted) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._stdout != rhs_storage._stdout {return false}
        if _storage._stderr != rhs_storage._stderr {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._commandLine != rhs_storage._commandLine {return false}
        if _storage._actionMetadataLogs != rhs_storage._actionMetadataLogs {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OutputGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.fileSets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OutputGroup, rhs: BuildEventStream_OutputGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    5: .standard(proto: "target_kind"),
    6: .standard(proto: "test_size"),
    2: .standard(proto: "output_group"),
    4: .standard(proto: "important_output"),
    8: .standard(proto: "directory_output"),
    3: .same(proto: "tag"),
    7: .standard(proto: "test_timeout_seconds"),
    9: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _targetKind: String = String()
    var _testSize: BuildEventStream_TestSize = .unknown
    var _outputGroup: [BuildEventStream_OutputGroup] = []
    var _importantOutput: [BuildEventStream_File] = []
    var _directoryOutput: [BuildEventStream_File] = []
    var _tag: [String] = []
    var _testTimeoutSeconds: Int64 = 0
    var _failureDetail: src_main_protobuf_failure_details_proto.FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _targetKind = source._targetKind
      _testSize = source._testSize
      _outputGroup = source._outputGroup
      _importantOutput = source._importantOutput
      _directoryOutput = source._directoryOutput
      _tag = source._tag
      _testTimeoutSeconds = source._testTimeoutSeconds
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._success)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._outputGroup)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._tag)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._importantOutput)
        case 5: try decoder.decodeSingularStringField(value: &_storage._targetKind)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._testSize)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._testTimeoutSeconds)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._directoryOutput)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._failureDetail)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if !_storage._outputGroup.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._outputGroup, fieldNumber: 2)
      }
      if !_storage._tag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tag, fieldNumber: 3)
      }
      if !_storage._importantOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._importantOutput, fieldNumber: 4)
      }
      if !_storage._targetKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetKind, fieldNumber: 5)
      }
      if _storage._testSize != .unknown {
        try visitor.visitSingularEnumField(value: _storage._testSize, fieldNumber: 6)
      }
      if _storage._testTimeoutSeconds != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testTimeoutSeconds, fieldNumber: 7)
      }
      if !_storage._directoryOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._directoryOutput, fieldNumber: 8)
      }
      if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetComplete, rhs: BuildEventStream_TargetComplete) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._targetKind != rhs_storage._targetKind {return false}
        if _storage._testSize != rhs_storage._testSize {return false}
        if _storage._outputGroup != rhs_storage._outputGroup {return false}
        if _storage._importantOutput != rhs_storage._importantOutput {return false}
        if _storage._directoryOutput != rhs_storage._directoryOutput {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._testTimeoutSeconds != rhs_storage._testTimeoutSeconds {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "status"),
    9: .standard(proto: "status_details"),
    4: .standard(proto: "cached_locally"),
    6: .standard(proto: "test_attempt_start_millis_epoch"),
    3: .standard(proto: "test_attempt_duration_millis"),
    2: .standard(proto: "test_action_output"),
    7: .same(proto: "warning"),
    8: .standard(proto: "execution_info"),
  ]

  fileprivate class _StorageClass {
    var _status: BuildEventStream_TestStatus = .noStatus
    var _statusDetails: String = String()
    var _cachedLocally: Bool = false
    var _testAttemptStartMillisEpoch: Int64 = 0
    var _testAttemptDurationMillis: Int64 = 0
    var _testActionOutput: [BuildEventStream_File] = []
    var _warning: [String] = []
    var _executionInfo: BuildEventStream_TestResult.ExecutionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _statusDetails = source._statusDetails
      _cachedLocally = source._cachedLocally
      _testAttemptStartMillisEpoch = source._testAttemptStartMillisEpoch
      _testAttemptDurationMillis = source._testAttemptDurationMillis
      _testActionOutput = source._testActionOutput
      _warning = source._warning
      _executionInfo = source._executionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._testActionOutput)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptDurationMillis)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._cachedLocally)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._status)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._testAttemptStartMillisEpoch)
        case 7: try decoder.decodeRepeatedStringField(value: &_storage._warning)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._executionInfo)
        case 9: try decoder.decodeSingularStringField(value: &_storage._statusDetails)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._testActionOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testActionOutput, fieldNumber: 2)
      }
      if _storage._testAttemptDurationMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptDurationMillis, fieldNumber: 3)
      }
      if _storage._cachedLocally != false {
        try visitor.visitSingularBoolField(value: _storage._cachedLocally, fieldNumber: 4)
      }
      if _storage._status != .noStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._testAttemptStartMillisEpoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptStartMillisEpoch, fieldNumber: 6)
      }
      if !_storage._warning.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._warning, fieldNumber: 7)
      }
      if let v = _storage._executionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._statusDetails.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusDetails, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult, rhs: BuildEventStream_TestResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusDetails != rhs_storage._statusDetails {return false}
        if _storage._cachedLocally != rhs_storage._cachedLocally {return false}
        if _storage._testAttemptStartMillisEpoch != rhs_storage._testAttemptStartMillisEpoch {return false}
        if _storage._testAttemptDurationMillis != rhs_storage._testAttemptDurationMillis {return false}
        if _storage._testActionOutput != rhs_storage._testActionOutput {return false}
        if _storage._warning != rhs_storage._warning {return false}
        if _storage._executionInfo != rhs_storage._executionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.protoMessageName + ".ExecutionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_seconds"),
    2: .same(proto: "strategy"),
    6: .standard(proto: "cached_remotely"),
    7: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "timing_breakdown"),
    5: .standard(proto: "resource_usage"),
  ]

  fileprivate class _StorageClass {
    var _timeoutSeconds: Int32 = 0
    var _strategy: String = String()
    var _cachedRemotely: Bool = false
    var _exitCode: Int32 = 0
    var _hostname: String = String()
    var _timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown? = nil
    var _resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeoutSeconds = source._timeoutSeconds
      _strategy = source._strategy
      _cachedRemotely = source._cachedRemotely
      _exitCode = source._exitCode
      _hostname = source._hostname
      _timingBreakdown = source._timingBreakdown
      _resourceUsage = source._resourceUsage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds)
        case 2: try decoder.decodeSingularStringField(value: &_storage._strategy)
        case 3: try decoder.decodeSingularStringField(value: &_storage._hostname)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._timingBreakdown)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._resourceUsage)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._cachedRemotely)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._exitCode)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._timeoutSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeoutSeconds, fieldNumber: 1)
      }
      if !_storage._strategy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._strategy, fieldNumber: 2)
      }
      if !_storage._hostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostname, fieldNumber: 3)
      }
      if let v = _storage._timingBreakdown {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._resourceUsage.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._resourceUsage, fieldNumber: 5)
      }
      if _storage._cachedRemotely != false {
        try visitor.visitSingularBoolField(value: _storage._cachedRemotely, fieldNumber: 6)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo, rhs: BuildEventStream_TestResult.ExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._strategy != rhs_storage._strategy {return false}
        if _storage._cachedRemotely != rhs_storage._cachedRemotely {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._hostname != rhs_storage._hostname {return false}
        if _storage._timingBreakdown != rhs_storage._timingBreakdown {return false}
        if _storage._resourceUsage != rhs_storage._resourceUsage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".TimingBreakdown"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "name"),
    3: .standard(proto: "time_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.child)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timeMillis)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.timeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.timeMillis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown, rhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.name != rhs.name {return false}
    if lhs.timeMillis != rhs.timeMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage, rhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "overall_status"),
    1: .standard(proto: "total_run_count"),
    3: .same(proto: "passed"),
    4: .same(proto: "failed"),
    6: .standard(proto: "total_num_cached"),
    7: .standard(proto: "first_start_time_millis"),
    8: .standard(proto: "last_stop_time_millis"),
    9: .standard(proto: "total_run_duration_millis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.totalRunCount)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.passed)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.failed)
      case 5: try decoder.decodeSingularEnumField(value: &self.overallStatus)
      case 6: try decoder.decodeSingularInt32Field(value: &self.totalNumCached)
      case 7: try decoder.decodeSingularInt64Field(value: &self.firstStartTimeMillis)
      case 8: try decoder.decodeSingularInt64Field(value: &self.lastStopTimeMillis)
      case 9: try decoder.decodeSingularInt64Field(value: &self.totalRunDurationMillis)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalRunCount != 0 {
      try visitor.visitSingularInt32Field(value: self.totalRunCount, fieldNumber: 1)
    }
    if !self.passed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passed, fieldNumber: 3)
    }
    if !self.failed.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failed, fieldNumber: 4)
    }
    if self.overallStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallStatus, fieldNumber: 5)
    }
    if self.totalNumCached != 0 {
      try visitor.visitSingularInt32Field(value: self.totalNumCached, fieldNumber: 6)
    }
    if self.firstStartTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.firstStartTimeMillis, fieldNumber: 7)
    }
    if self.lastStopTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.lastStopTimeMillis, fieldNumber: 8)
    }
    if self.totalRunDurationMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.totalRunDurationMillis, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestSummary, rhs: BuildEventStream_TestSummary) -> Bool {
    if lhs.overallStatus != rhs.overallStatus {return false}
    if lhs.totalRunCount != rhs.totalRunCount {return false}
    if lhs.passed != rhs.passed {return false}
    if lhs.failed != rhs.failed {return false}
    if lhs.totalNumCached != rhs.totalNumCached {return false}
    if lhs.firstStartTimeMillis != rhs.firstStartTimeMillis {return false}
    if lhs.lastStopTimeMillis != rhs.lastStopTimeMillis {return false}
    if lhs.totalRunDurationMillis != rhs.totalRunDurationMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_success"),
    3: .standard(proto: "exit_code"),
    2: .standard(proto: "finish_time_millis"),
    4: .standard(proto: "anomaly_report"),
  ]

  fileprivate class _StorageClass {
    var _overallSuccess: Bool = false
    var _exitCode: BuildEventStream_BuildFinished.ExitCode? = nil
    var _finishTimeMillis: Int64 = 0
    var _anomalyReport: BuildEventStream_BuildFinished.AnomalyReport? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _overallSuccess = source._overallSuccess
      _exitCode = source._exitCode
      _finishTimeMillis = source._finishTimeMillis
      _anomalyReport = source._anomalyReport
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._overallSuccess)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._finishTimeMillis)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._exitCode)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._anomalyReport)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._overallSuccess != false {
        try visitor.visitSingularBoolField(value: _storage._overallSuccess, fieldNumber: 1)
      }
      if _storage._finishTimeMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._finishTimeMillis, fieldNumber: 2)
      }
      if let v = _storage._exitCode {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._anomalyReport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished, rhs: BuildEventStream_BuildFinished) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._overallSuccess != rhs_storage._overallSuccess {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._finishTimeMillis != rhs_storage._finishTimeMillis {return false}
        if _storage._anomalyReport != rhs_storage._anomalyReport {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.ExitCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".ExitCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt32Field(value: &self.code)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.ExitCode, rhs: BuildEventStream_BuildFinished.ExitCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.AnomalyReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".AnomalyReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "was_suspended"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.wasSuspended)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wasSuspended != false {
      try visitor.visitSingularBoolField(value: self.wasSuspended, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.AnomalyReport, rhs: BuildEventStream_BuildFinished.AnomalyReport) -> Bool {
    if lhs.wasSuspended != rhs.wasSuspended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_summary"),
    2: .standard(proto: "memory_metrics"),
    3: .standard(proto: "target_metrics"),
    4: .standard(proto: "package_metrics"),
    5: .standard(proto: "timing_metrics"),
  ]

  fileprivate class _StorageClass {
    var _actionSummary: BuildEventStream_BuildMetrics.ActionSummary? = nil
    var _memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics? = nil
    var _targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics? = nil
    var _packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics? = nil
    var _timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actionSummary = source._actionSummary
      _memoryMetrics = source._memoryMetrics
      _targetMetrics = source._targetMetrics
      _packageMetrics = source._packageMetrics
      _timingMetrics = source._timingMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._actionSummary)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._memoryMetrics)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._targetMetrics)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._packageMetrics)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._timingMetrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._actionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._memoryMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._targetMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._packageMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._timingMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics, rhs: BuildEventStream_BuildMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionSummary != rhs_storage._actionSummary {return false}
        if _storage._memoryMetrics != rhs_storage._memoryMetrics {return false}
        if _storage._targetMetrics != rhs_storage._targetMetrics {return false}
        if _storage._packageMetrics != rhs_storage._packageMetrics {return false}
        if _storage._timingMetrics != rhs_storage._timingMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actions_created"),
    2: .standard(proto: "actions_executed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.actionsCreated)
      case 2: try decoder.decodeSingularInt64Field(value: &self.actionsExecuted)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsCreated != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreated, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary, rhs: BuildEventStream_BuildMetrics.ActionSummary) -> Bool {
    if lhs.actionsCreated != rhs.actionsCreated {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".MemoryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_heap_size_post_build"),
    2: .standard(proto: "peak_post_gc_heap_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.usedHeapSizePostBuild)
      case 2: try decoder.decodeSingularInt64Field(value: &self.peakPostGcHeapSize)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedHeapSizePostBuild != 0 {
      try visitor.visitSingularInt64Field(value: self.usedHeapSizePostBuild, fieldNumber: 1)
    }
    if self.peakPostGcHeapSize != 0 {
      try visitor.visitSingularInt64Field(value: self.peakPostGcHeapSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics) -> Bool {
    if lhs.usedHeapSizePostBuild != rhs.usedHeapSizePostBuild {return false}
    if lhs.peakPostGcHeapSize != rhs.peakPostGcHeapSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TargetMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TargetMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "targets_loaded"),
    2: .standard(proto: "targets_configured"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.targetsLoaded)
      case 2: try decoder.decodeSingularInt64Field(value: &self.targetsConfigured)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetsLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsLoaded, fieldNumber: 1)
    }
    if self.targetsConfigured != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfigured, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TargetMetrics, rhs: BuildEventStream_BuildMetrics.TargetMetrics) -> Bool {
    if lhs.targetsLoaded != rhs.targetsLoaded {return false}
    if lhs.targetsConfigured != rhs.targetsConfigured {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.PackageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".PackageMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packages_loaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.packagesLoaded)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packagesLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.packagesLoaded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.PackageMetrics, rhs: BuildEventStream_BuildMetrics.PackageMetrics) -> Bool {
    if lhs.packagesLoaded != rhs.packagesLoaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TimingMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TimingMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_time_in_ms"),
    2: .standard(proto: "wall_time_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.cpuTimeInMs)
      case 2: try decoder.decodeSingularInt64Field(value: &self.wallTimeInMs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuTimeInMs, fieldNumber: 1)
    }
    if self.wallTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.wallTimeInMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TimingMetrics, rhs: BuildEventStream_BuildMetrics.TimingMetrics) -> Bool {
    if lhs.cpuTimeInMs != rhs.cpuTimeInMs {return false}
    if lhs.wallTimeInMs != rhs.wallTimeInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildToolLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildToolLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.log)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildToolLogs, rhs: BuildEventStream_BuildToolLogs) -> Bool {
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlinksIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlinksIdentified"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "convenience_symlinks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.convenienceSymlinks)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.convenienceSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convenienceSymlinks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlinksIdentified, rhs: BuildEventStream_ConvenienceSymlinksIdentified) -> Bool {
    if lhs.convenienceSymlinks != rhs.convenienceSymlinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "action"),
    3: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularEnumField(value: &self.action)
      case 3: try decoder.decodeSingularStringField(value: &self.target)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlink, rhs: BuildEventStream_ConvenienceSymlink) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.action != rhs.action {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "DELETE"),
  ]
}

extension BuildEventStream_BuildEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "children"),
    20: .standard(proto: "last_message"),
    3: .same(proto: "progress"),
    4: .same(proto: "aborted"),
    5: .same(proto: "started"),
    12: .standard(proto: "unstructured_command_line"),
    22: .standard(proto: "structured_command_line"),
    13: .standard(proto: "options_parsed"),
    16: .standard(proto: "workspace_status"),
    21: .same(proto: "fetch"),
    17: .same(proto: "configuration"),
    6: .same(proto: "expanded"),
    18: .same(proto: "configured"),
    7: .same(proto: "action"),
    15: .standard(proto: "named_set_of_files"),
    8: .same(proto: "completed"),
    10: .standard(proto: "test_result"),
    9: .standard(proto: "test_summary"),
    14: .same(proto: "finished"),
    23: .standard(proto: "build_tool_logs"),
    24: .standard(proto: "build_metrics"),
    25: .standard(proto: "workspace_info"),
    26: .standard(proto: "build_metadata"),
    27: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId? = nil
    var _children: [BuildEventStream_BuildEventId] = []
    var _lastMessage: Bool = false
    var _payload: BuildEventStream_BuildEvent.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _children = source._children
      _lastMessage = source._lastMessage
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._children)
        case 3:
          var v: BuildEventStream_Progress?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .progress(v)}
        case 4:
          var v: BuildEventStream_Aborted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .aborted(v)}
        case 5:
          var v: BuildEventStream_BuildStarted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .started(v)}
        case 6:
          var v: BuildEventStream_PatternExpanded?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .expanded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .expanded(v)}
        case 7:
          var v: BuildEventStream_ActionExecuted?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .action(v)}
        case 8:
          var v: BuildEventStream_TargetComplete?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .completed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .completed(v)}
        case 9:
          var v: BuildEventStream_TestSummary?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testSummary(v)}
        case 10:
          var v: BuildEventStream_TestResult?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .testResult(v)}
        case 12:
          var v: BuildEventStream_UnstructuredCommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .unstructuredCommandLine(v)}
        case 13:
          var v: BuildEventStream_OptionsParsed?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .optionsParsed(v)}
        case 14:
          var v: BuildEventStream_BuildFinished?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .finished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .finished(v)}
        case 15:
          var v: BuildEventStream_NamedSetOfFiles?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .namedSetOfFiles(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .namedSetOfFiles(v)}
        case 16:
          var v: BuildEventStream_WorkspaceStatus?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .workspaceStatus(v)}
        case 17:
          var v: BuildEventStream_Configuration?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configuration(v)}
        case 18:
          var v: BuildEventStream_TargetConfigured?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .configured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .configured(v)}
        case 20: try decoder.decodeSingularBoolField(value: &_storage._lastMessage)
        case 21:
          var v: BuildEventStream_Fetch?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .fetch(v)}
        case 22:
          var v: src_main_protobuf_command_line_proto.CommandLine_CommandLine?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .structuredCommandLine(v)}
        case 23:
          var v: BuildEventStream_BuildToolLogs?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildToolLogs(v)}
        case 24:
          var v: BuildEventStream_BuildMetrics?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildMetrics(v)}
        case 25:
          var v: BuildEventStream_WorkspaceConfig?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .workspaceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .workspaceInfo(v)}
        case 26:
          var v: BuildEventStream_BuildMetadata?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .buildMetadata(v)}
        case 27:
          var v: BuildEventStream_ConvenienceSymlinksIdentified?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .convenienceSymlinksIdentified(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 2)
      }
      switch _storage._payload {
      case .progress(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .aborted(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .started(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .expanded(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .action(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .completed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .testSummary(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .testResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .unstructuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .optionsParsed(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .finished(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .namedSetOfFiles(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .workspaceStatus(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .configuration(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .configured(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case nil: break
      default: break
      }
      if _storage._lastMessage != false {
        try visitor.visitSingularBoolField(value: _storage._lastMessage, fieldNumber: 20)
      }
      switch _storage._payload {
      case .fetch(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .structuredCommandLine(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .buildToolLogs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .buildMetrics(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .workspaceInfo(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .buildMetadata(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .convenienceSymlinksIdentified(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEvent, rhs: BuildEventStream_BuildEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
